








































PowerPoint Presentation

Unit – 3
Parsing Theory (I)
dixita.kagathara@darshan.ac.in
+91 - 97277 47317 (CE Department)
Computer Engineering Department
Prof. Dixita B. Kagathara
Compiler Design (CD)
GTU # 2170701


Darshan Institute of Engineering & Technology, Rajkot




Looping
Topics to be covered 
Role of parser
Context free grammar
Derivation & Ambiguity
Left recursion & Left factoring
Classification of parsing
Backtracking
LL(1) parsing
Recursive descent paring
Shift reduce parsing
Operator precedence parsing
LR parsing












Role of Parser







Role of parser

Parser obtains a string of token from the lexical analyzer and reports  syntax error if any otherwise generates syntax tree.
There are two types of parser:
 Top-down parser
 Bottom-up parser

Rest of front end
Parse tree
Token
IR
Lexical analyzer
Symbol table
Parser
Get next token
Source program
Parsetree



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Context free grammar







Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and it’s a start symbol,
 is a finite set formulas of the form  where  and 


Nonterminal symbol: 
The name of syntax category of a language, e.g., noun, verb, etc. 
The It is written as a single capital letter, or as a name enclosed between < … >, e.g., A or <Noun>


<Noun Phrase> → <Article><Noun>
<Article> → a | an | the
<Noun> → boy | apple






Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and it’s a start symbol,
 is a finite set formulas of the form  where  and 


Terminal symbol: 
A symbol in the alphabet. 
It is denoted by lower case letter and punctuation marks used in language.


<Noun Phrase> → <Article><Noun>
<Article> → a | an | the
<Noun> → boy | apple








Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and it’s a start symbol,
 is a finite set formulas of the form  where  and 


Start symbol: 
First nonterminal symbol of the grammar is called start symbol. 


<Noun Phrase> → <Article><Noun>
<Article> → a | an | the
<Noun> → boy | apple




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and it’s a start symbol,
 is a finite set formulas of the form  where  and 


Production:  
A production, also called a rewriting rule, is a rule of grammar. It has the form of
A nonterminal symbol → String of terminal and nonterminal symbols
 


<Noun Phrase> → <Article><Noun>
<Article> → a | an | the
<Noun> → boy | apple






Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Grammar
Write terminals, non terminals, start symbol, and productions for following grammar.
E  E O E| (E) | -E | id
O  + | - | * | /  | ↑

Terminals: 	id + - * / ↑ ( )
Non terminals: E, O
Start symbol: 	E
Productions: 	E  E O E| (E) | -E | id
		O  + | - | * | /  | ↑




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Derivation & Ambiguity







Derivation
Derivation is used to find whether the string belongs to a given grammar or not.
Types of derivations are:
 Leftmost derivation
 Rightmost derivation




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Leftmost derivation 
A derivation of a string  in a grammar  is a left most derivation if at every step the left most non terminal is replaced.
Grammar: SS+S | S-S | S*S | S/S | a 	Output string: a*a-a


		S
	S-S
S*S-S
a*S-S
a*a-S
	a*a-a


a
S
-
S
a
a
S
*
S
S
Parse tree represents the structure of derivation  
Leftmost Derivation
Parse tree



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Rightmost derivation 
A derivation of a string  in a grammar  is a right most derivation if at every step the right most non terminal is replaced.
It is all called canonical derivation.
Grammar: SS+S | S-S | S*S | S/S | a 	Output string: a*a-a


         S
		S*S
		 S*S-S
		 S*S-a
		 S*a-a
		 a*a-a

a
S
*
S
a
a
S
-
S
S
Rightmost Derivation
Parse Tree



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Exercise: Derivation
Perform leftmost derivation and draw parse tree.
	SA1B
A0A | 𝜖
B0B | 1B | 𝜖 
Output string: 1001
Perform leftmost derivation and draw parse tree.
      S0S1 | 01   Output string: 000111
Perform rightmost derivation and draw parse tree.
EE+E | E*E | id | (E) | -E
Output string: id + id * id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Ambiguous grammar







Ambiguity
Ambiguity, is a word, phrase, or statement which contains more than one meaning.

Chip
A long thin piece of potato
A small piece of silicon





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Ambiguity
In formal language grammar, ambiguity would arise if identical string can occur on the RHS of two or more productions.
Grammar:
	
	
 can be derived from either N1 or N2




Replaced by
 or  ?



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Ambiguous grammar
Ambiguous grammar is one that produces more than one leftmost or more then one rightmost derivation for the same sentence.
Grammar: SS+S | S*S | (S) | a		Output string: a+a*a

	    S					   	    S
	S*S						S+S
	S+S*S					a+S
	a+S*S					a+S*S
	a+a*S					a+a*S
	a+a*a					a+a*a
Here, Two leftmost derivation for string a+a*a is possible hence, above grammar is ambiguous.

a
S
*
S
a
a
S
S
+
S
a
S
+
S
a
a
S
*
S
S



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Exercise: Ambiguous Grammar
Check Ambiguity in following grammars:
S aS | Sa | 𝜖  (output string: aaaa)
S aSbS | bSaS | 𝜖  (output string: abab)
S SS+ | SS* | a (output string: aa+a*)
<exp> → <exp> + <term> | <term>
<term> → <term> * <letter> | <letter> 
<letter> → a|b|c|…|z  (output string: a+b*c) 
Prove that the CFG with productions: S  a | Sa | bSS | SSb | SbS  is ambiguous (Hint: consider output string yourself)




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Left recursion & Left factoring







Left recursion
A grammar is said to be left recursive if it has a non terminal  such that there is a derivation for some string 
Algorithm to eliminate left recursion
Arrange the non terminals in some order  
For  do begin
	for  do begin
 		replace each production of the form   
			by the productions ,
			where are all the current 				productions;
 	 end
 	 eliminate the immediate left recursion among the  - productions
end




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›



Left recursion elimination

  




𝜖



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Examples: Left recursion elimination
EE+T | T
				ETE’
				E’+TE’ | ε
TT*F | F
				TFT’
				T’*FT’ | ε 
XX%Y | Z
				XZX’
				X’%YX’ | ε 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Exercise: Left recursion
AAbd | Aa | a
       BBe | b
AAB | AC | a | b
SA | B
AABC | Acd | a | aa
BBee | b
ExpExp+term | Exp-term | term





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Left factoring
Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive parsing.
Algorithm to left factor a grammar
Input: Grammar G
Output: An equivalent left factored grammar.
Method: 
For each non terminal A find the longest prefix  common to two or more of its alternatives. If , i.e.,  there is a non trivial common prefix, replace all the  productions where  represents all alternatives that do not begin with  by
	 

Here A' is new non terminal. Repeatedly apply this transformation until no two alternatives for a non-terminal have a common prefix.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›




δ
Left factoring elimination
  

δ


|
  
  
  



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Left factoring elimination
SaAB | aCD
			SaS’
			S’AB | CD
A xByA | xByAzA | a

			A xByAA’ | a
			A’ Є | zA 
A aAB | aA |a
			AaA’
			A’AB | A | 𝜖
			A’AA’’ | 𝜖
			A’’B | 𝜖 




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Exercise
SiEtS | iEtSeS | a
A ad | a | ab | abc | x




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing







Parsing
Parsing is a technique that takes input string and produces output either a parse tree if string is valid sentence of grammar, or an error message indicating that string is not a valid.
Types of parsing are:
Top down parsing: In top down parsing parser build parse tree from top to bottom.
Bottom up parsing: Bottom up parser starts from leaves and work up to the root.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Classification of parsing methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Backtracking
In backtracking, expansion of nonterminal symbol we choose one alternative and if any mismatch occurs then we try another alternative. 
Grammar: S cAd		Input string: cad
	        A ab | a
c
A
d
S
c
A
d
S
a
b
c
A
d
S
a
Parsing done
Make prediction
Backtrack
Make prediction



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Exercise
E 5+T | 3-T
T V | V*V | V+V
V a | b
String: 3-a+b




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

LL(1) parser (predictive parser)
LL(1) is non recursive top down parser.
First L indicates input is scanned from left to right. 
The second L means it uses leftmost derivation for input string 
 1 means it uses only input symbol to predict the parsing process.

Predictive parsing program
Parsing table M
INPUT
OUTPUT
  Stack 
	a	+	b	$	

	X
	Y
	Z
	$




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

LL(1) parsing (predictive parsing)
Steps to construct LL(1) parser
Remove left recursion / Perform left factoring (if any).
Compute FIRST and FOLLOW of non terminals.
Construct predictive parsing table.
Parse the input string using parsing table.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Rules to compute first of non terminal
If and  is terminal, add  to .
If , add to .
If  is nonterminal and is a production, then place  in  if for some , a is in , and 𝜖 is in all of that is . If 𝜖 is in  for all then add 𝜖 to .
Everything in  is surely in  If  does not derive 𝜖, then we do nothing more to , but if , then we add  and so on.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Rules to compute first of non terminal
Simplification of Rule 3
If  , 
 If  does not derives 
 If  derives 
 
 If  & Y2 derives ∈
 
If  , Y2 & Y3 derives ∈

If  , Y2 , Y3 …..YK all derives ∈ 
(note: if all non terminals derives ∈ then add ∈ to FIRST(A))




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Rules to compute FOLLOW of non terminal
Place S is start symbol)
If then everything in  except for 𝜖 is placed in  
If there is a production or a production  where  contains  then everything in 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

How to apply rules to find FOLLOW of non terminal?







 𝜖
 𝜖





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Rules to construct predictive parsing table
For each production  of the grammar, do steps 2 and 3.
For each terminal  in , Add  to .
If  is in , Add  to  for each terminal  in . If  is in , and  is in , add  to .
Make each undefined entry of M be error.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-1: LL(1) parsing


Step 1: Not required 
Step 2: Compute FIRST
First(S)
SaBa

First(B)
BbB 					B𝜖

SaBa
	BbB | ϵ
	
	S		a	B	a

	A		

	B		𝜖

	A		

Rule 1
add  to 
Rule 2
add  to 
FIRST(B)={ b 
 , 𝜖 }
	NT	First

	S	{ a }

	B	{b,𝜖}


	B		b	B

	A		

Rule 1
add  to 

FIRST(S)={ a } 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-1: LL(1) parsing


Step 2: Compute FOLLOW
Follow(S)


Follow(B)
SaBa 				BbB 

SaBa
	BbB | ϵ
	
Follow(B)={ a  
	B		b	B

Follow(S)={ $ } 
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{a}

	S		a	B	a

	A 			B

Rule 3
Follow(A)=follow(B)
	A			B	

Rule 2
First(


Rule 1: Place $ in FOLLOW(S)


 }



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-1: LL(1) parsing


Step 3: Prepare predictive parsing table





SaBa
a=FIRST(aBa)={ a }
M[S,a]=SaBa

SaBa
	BbB | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{a}

	NT	Input Symbol		
		a	b	$
	S	SaBa		
	B			

Rule: 2
A 
a = first()
M[A,a] = A 




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-1: LL(1) parsing


Step 3: Prepare predictive parsing table





BbB
a=FIRST(bB)={ b }
M[B,b]=BbB

SaBa
	BbB | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{a}

	NT	Input Symbol		
		a	b	$
	S	SaBa		
	B		BbB	

Rule: 2
A 
a = first()
M[A,a] = A 




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-1: LL(1) parsing


Step 3: Prepare predictive parsing table





Bϵ
b=FOLLOW(B)={ a }
M[B,a]=B𝜖


SaBa
	BbB | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{a}

	NT	Input Symbol		
		a	b	$
	S	SaBa	Error	Error
	B	Bϵ	BbB	Error


Rule: 3
A 
b = follow(A)
M[A,b] = A 






Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 1: Not required 
Step 2: Compute FIRST
First(S)
SaB 					S𝜖


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	S		𝜖

	A		

Rule 2
add  to 
FIRST(S)={ a 
 , 𝜖 }
	NT	First

	S	{ a, 𝜖 }

	B	{b,𝜖}


	S		a	B

	A		

Rule 1
add  to 
	C	{c,𝜖}






Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 1: Not required 
Step 2: Compute FIRST
First(B)
BbC 					B𝜖


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	B		𝜖

	A		

Rule 2
add  to 
FIRST(B)={ b 
 , 𝜖 }
	NT	First

	S	{ a, 𝜖 }

	B	{b,𝜖}

	B		b	C

	A		

Rule 1
add  to 
	C	{c,𝜖}






Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 1: Not required 
Step 2: Compute FIRST
First(C)
CcS 					C𝜖


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	C		𝜖

	A		

Rule 2
add  to 
FIRST(B)={ c 
 , 𝜖 }
	NT	First

	S	{ a, 𝜖 }

	B	{b,𝜖}

	C		c	S

	A		

Rule 1
add  to 
	C	{c,𝜖}





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing
Step 2: Compute FOLLOW
Follow(S)

CcS






BbC 					SaB 

 

 ={$}
	C		c	S

Follow(S)={ $ } 
	NT	First 	Follow 
	S	{a,𝜖}	{$}
	B	{b,𝜖}	{$}
	C	{c,𝜖}	{$}

	A 			B

Rule 3
Follow(A)=follow(B)
Rule 1: Place $ in FOLLOW(S)


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
Follow(S)=Follow(C) 
	B		b	C

	A 			B

Rule 3
Follow(A)=follow(B)
Follow(C)=Follow(B) 
 ={$}
	S		a	B

	A 			B

Rule 3
Follow(A)=follow(B)
Follow(B)=Follow(S) 
 ={$}






Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





SaB
a=FIRST(aB)={ a }
M[S,a]=SaB

	NT	Input Symbol			
		a	b	c	$
	S	SaB			
	B				
	C				

Rule: 2
A 
a = first()
M[A,a] = A 

SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	NT	First 	Follow 
	S	{a,𝜖}	{$}
	B	{b,𝜖}	{$}
	C	{c,𝜖}	{$}




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





S𝜖
b=FOLLOW(S)={ $ }
M[S,$]=S𝜖

	NT	Input Symbol			
		a	b	c	$
	S	SaB			S𝜖
	B				
	C				


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{$}
	C	{c,𝜖}	{$}

Rule: 3
A 
b = follow(A)
M[A,b] = A 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





BbC
a=FIRST(bC)={ b }
M[B,b]=BbC

	NT	Input Symbol			
		a	b	c	$
	S	SaB			S𝜖
	B		BbC		
	C				


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{$}
	C	{c,𝜖}	{$}

Rule: 2
A 
a = first()
M[A,a] = A 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





B𝜖
b=FOLLOW(B)={ $ }
M[B,$]=B𝜖

	NT	Input Symbol			
		a	b	c	$
	S	SaB			S𝜖
	B		BbC		B𝜖
	C				


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{$}
	C	{c,𝜖}	{$}

Rule: 3
A 
b = follow(A)
M[A,b] = A 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





CcS
a=FIRST(cS)={ c }
M[C,c]=CcS

	NT	Input Symbol			
		a	b	c	$
	S	SaB			S𝜖
	B		BbC		B𝜖
	C			CcS	


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{$}
	C	{c,𝜖}	{$}

Rule: 2
A 
a = first()
M[A,a] = A 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





C𝜖
b=FOLLOW(C)={ $ }
M[C,$]=C𝜖

	NT	Input Symbol			
		a	b	c	$
	S	SaB	Error	Error	S𝜖
	B	Error	BbB	Error	B𝜖
	C	Error	Error	CcS	C𝜖


SaB | ϵ
	BbC | ϵ
CcS | ϵ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,𝜖}	{$}
	C	{c,𝜖}	{$}

Rule: 3
A 
b = follow(A)
M[A,b] = A 









Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
EE+T | T
TT*F | F
F(E) | id
Step 1: Remove left recursion
	ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FIRST
First(E)
ETE’


First(T)
TFT’

First(F)
F(E) 					Fid


ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id

	E		T	E’

	A		Y1	Y2

Rule 3
First(A)=First(Y1)
	T		F	T’

	A		Y1	Y2

Rule 3
First(A)=First(Y1)
FIRST(E)=FIRST(T)
FIRST(T)=FIRST(F)
	F		(	E	)

	A		

	F		id

	A		

Rule 1
add  to 
Rule 1
add  to 
FIRST(F)={ ( 
 , id }
	NT	First

	E	{ (,id }

	E’	

	T	{ (,id }

	T’	

	F	{ (,id }




= {(, id }
= {(, id }



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FIRST
First(E’)
E’+TE’



E’𝜖



	A		

	E’		

	A		

Rule 1
add  to 
Rule 2
add  to 
FIRST(E’)={ +
, 𝜖 }
	E’		+	T	E’

	NT	First

	E	{ (,id }

	E’	{ +, 𝜖 }

	T	{ (,id }

	T’	

	F	{ (,id }

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FIRST
First(T’)
T’*FT’



T’𝜖



	A		

	T’		

	A		

Rule 1
add  to 
Rule 2
add  to 
FIRST(T’)={ *
, 𝜖 }
	T’		*	F	T’

	NT	First

	E	{ (,id }

	E’	{ +, 𝜖 }

	T	{ (,id }

	T’	{ *, 𝜖 }

	F	{ (,id }

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(E)

F(E)
	


	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	

	T	{ (,id }	

	T’	{ *, 𝜖 }	

	F	{ (,id }	

Rule 1: Place $ in FOLLOW(E)
FOLLOW(E)={ $,
	F 		(	E	)

	A 			B	

Rule 2

) }

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(E’)
ETE’



E’+TE’
	

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	

	T’	{ *, 𝜖 }	

	F	{ (,id }	

FOLLOW(E’)={ $,)
	E 		T	E’

	A 			B

Rule 3


	E’		+T	E’

	A 			B

Rule 3

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id

}



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(T)
ETE’



	

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	

	T’	{ *, 𝜖 }	

	F	{ (,id }	

FOLLOW(T)={ +,
	E 			T	E’

	A 			B	

$, ) 
	E			T	E’

	A 			B	

Rule 3

Rule 2

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(T)
E’+TE’

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	

	F	{ (,id }	

FOLLOW(T)={ +,
	E’ 		+	T	E’

	A 			B	

$, )

Rule 3

Rule 2

	E’ 		+	T	E’

	A 			B	

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id

} 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(T’)
TFT’



T’*FT’
	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	

FOLLOW(T’)={+ $,)
	T		F	T’

	A 			B

Rule 3


	T’		*F	T’

	A 			B

Rule 3

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id

}



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(F)
TFT’

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	

FOLLOW(F)={ *,
	T 			F	T’

	A 			B	

 + ,$ , ) 
	T			F	T’

	A 			B	

Rule 3

Rule 2

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(F)
T’*FT’



	


	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

FOLLOW(F)={ *,+,
	T’ 		*	F	T’

	A 			B	

$, )

Rule 3

Rule 2

	T’ 		*	F	T’

	A 			B	

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id

} 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







ETE’
a=FIRST(TE’)={ (,id }
M[E,(]=ETE’
M[E,id]=ETE’

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Rule: 2
A 
a = first()
M[A,a] = A 
	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’						
	T						
	T’						
	F						



ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







E’+TE’
a=FIRST(+TE’)={ + }
M[E’,+]=E’+TE’

	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’		E’+TE’				
	T						
	T’						
	F						

Rule: 2
A 
a = first()
M[A,a] = A 

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







E’𝜖
b=FOLLOW(E’)={ $,) }
M[E’,$]=E’𝜖
M[E’,)]=E’𝜖

	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’		E’+TE’			E’𝜖	E’𝜖
	T						
	T’						
	F						

Rule: 3
A 
b = follow(A)
M[A,b] = A 


	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







TFT’
a=FIRST(FT’)={ (,id }
M[T,(]=TFT’
M[T,id]=TFT’


	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’		E’+TE’			E’𝜖	E’𝜖
	T	TFT’			TFT’		
	T’						
	F						



	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id

Rule: 2
A 
a = first()
M[A,a] = A 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







T’*FT’
a=FIRST(*FT’)={ * }
M[T’,*]=T’*FT’

	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’		E’+TE’			E’𝜖	E’𝜖
	T	TFT’			TFT’		
	T’			T’*FT’			
	F						

Rule: 2
A 
a = first()
M[A,a] = A 

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table






T’𝜖
b=FOLLOW(T’)={ +,$,) }
M[T’,+]=T’𝜖
M[T’,$]=T’𝜖
M[T’,)]=T’𝜖

	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’		E’+TE’			E’𝜖	E’𝜖
	T	TFT’			TFT’		
	T’		T’𝜖	T’*FT’		T’𝜖	T’𝜖
	F						

Rule: 3
A 
b = follow(A)
M[A,b] = A 



	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table








F(E)
a=FIRST((E))={ ( }
M[F,(]=F(E)

	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’		E’+TE’			E’𝜖	E’𝜖
	T	TFT’			TFT’		
	T’		T’𝜖	T’*FT’		T’𝜖	T’𝜖
	F				F(E)		

Rule: 2
A 
a = first()
M[A,a] = A 

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table








Fid
a=FIRST(id)={ id }
M[F,id]=Fid

	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’			ETE’		
	E’		E’+TE’			E’𝜖	E’𝜖
	T	TFT’			TFT’		
	T’		T’𝜖	T’*FT’		T’𝜖	T’𝜖
	F	Fid			F(E)		

Rule: 2
A 
a = first()
M[A,a] = A 

	NT	First	Follow

	E	{ (,id }	{ $,) }

	E’	{ +, 𝜖 }	{ $,) }

	T	{ (,id }	{ +,$,) }

	T’	{ *, 𝜖 }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

ETE’
	E’+TE’ | ϵ
	TFT’
	T’*FT’ | ϵ
	F(E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 4: Make each undefined entry of table be Error

	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’	Error	Error	ETE’	Error	Error
	E’	Error	E’+TE’	Error	Error	E’𝜖	E’𝜖
	T	TFT’	Error	Error	TFT’	Error	Error
	T’	Error	T’𝜖	T’*FT’	Error	T’𝜖	T’𝜖
	F	Fid	Error	Error	F(E)	Error	Error




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example-3: LL(1) parsing
Step 4: Parse the string : id + id * id $

	STACK	INPUT	OUTPUT

	E$	id+id*id$	

	TE’$	id+id*id$	ETE’

	FT’E’$	id+id*id$	TFT’

	idT’E’$	id+id*id$	Fid

	T’E’$	+id*id$	

	+TE’$	+id*id$	E’+TE’

	E’$	+id*id$	T’𝜖

	idT’E’$	id$	Fid

	TE’$	id*id$	

	T’E’$	$	

	FT’E’$	id*id$	TFT’

	E’$	$	T’𝜖

	FT’E’$	id$	

	$	$	E’𝜖

	*FT’E’$	*id$	T*FT’

	T’E’$	*id$	

	idT’E’$	id*id$	Fid













































	NT	Input Symbol					
		id	+	*	(	)	$
	E	ETE’	Error	Error	ETE’	Error	Error
	E’	Error	E’+TE’	Error	Error	E’𝜖	E’𝜖
	T	TFT’	Error	Error	TFT’	Error	Error
	T’	Error	T’𝜖	T’*FT’	Error	T’𝜖	T’𝜖
	F	Fid	Error	Error	F(E)	Error	Error




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Recursive descent parsing
A top down parsing that executes a set of recursive procedure to process the input without backtracking is called recursive descent parser.
There is a procedure for each non terminal in the grammar.
Consider RHS of any production rule as definition of the procedure.
As it reads expected input symbol, it advances input pointer to next position.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Recursive descent parsing
Procedure E
{
	If lookahead=num 
	{
		Match(num);
		T();
	}
	Else
		Error();
	If lookahead=$
	{
		Declare success;
	}
	Else
		Error();
}

Procedure T
{
	If lookahead=’*’ 
	{
		Match(‘*’);
		If lookahead=num 
		{
			Match(num);
			T();
		}
		Else
			Error();
 
	}
	Else
		NULL
}
Proceduce Match(token t)
{
	If lookahead=t
	lookahead=next_token;
	Else
		Error();
}
Procedure Error
{
	Print(“Error”);
}
	
	E 
	T
	3	*	4	$


num
T
num
*
T
| 𝜖

Success



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Recursive descent parsing
Procedure E
{
	If lookahead=num 
	{
		Match(num);
		T();
	}
	Else
		Error();
	If lookahead=$
	{
		Declare success;
	}
	Else
		Error();
}

Procedure T
{
	If lookahead=’*’ 
	{
		Match(‘*’);
		If lookahead=num 
		{
			Match(num);
			T();
		}
		Else
			Error();
 
	}
	Else
		NULL
}
Proceduce Match(token t)
{
	If lookahead=t
	lookahead=next_token;
	Else
		Error();
}
Procedure Error
{
	Print(“Error”);
}
	
	E 
	T
num
T
num
*
T
| 𝜖
Success
	3	4	*	$

Error
	3	*	4	$




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Handle & Handle pruning
Handle: A “handle” of a string is a substring of the string that matches the right side of a production, and whose reduction to the non terminal of the production is one step along the reverse of rightmost derivation.
Handle pruning: The process of discovering a handle and reducing it to appropriate left hand side non terminal is known as handle pruning.

EE+E
EE*E
Eid
String: id1+id2*id3
	Right sentential form	Handle	Production

	id1+id2*id3	id1	Eid 

	E+id2*id3	id2	Eid

	E+E*id3	id3	Eid

	E+E*E	E*E	EE*E

	E+E	E+E	EE+E 

	E		
















Rightmost Derivation
E
E+E
E+E*E
E+E*id3
E+id2*id3
id1+id2*id3



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Shift reduce parser
The shift reduce parser performs following basic operations:
Shift: Moving of the symbols from input buffer onto the stack, this action is called shift.
Reduce: If handle appears on the top of the stack then reduction of it by appropriate rule is done. This action is called reduce action.
Accept: If stack contains start symbol only and input buffer is empty at the same time then that action is called accept.
Error: A situation in which parser cannot either shift or reduce the symbols, it cannot even perform accept action then it is called error action.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Shift reduce parser
	Stack 	Input Buffer	Action

	$	id+id*id$	Shift 


	$id	+id*id$	Reduce Fid

	$F	+id*id$	Reduce TF

	$T	+id*id$	Reduce ET

	$E	+id*id$	Shift 

	$E+	id*id$	Shift 

	$E+id	*id$	Reduce Fid

	$E+F	*id$	Reduce TF

	$E+T	*id$	Shift 

	$E+T*	id$	Shift 

	$E+T*id	$	Reduce Fid 

	$E+T*F	$	Reduce TT*F 

	$E+T	$	Reduce EE+T

	$E	$	Accept 













































Grammar:
EE+T | T
TT*F | F
Fid
String: id+id*id



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Viable Prefix
The set of prefixes of right sentential forms that can appear on the stack of a shift-reduce parser are called viable prefixes.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence parsing
Operator Grammar: A Grammar in which there is no Є in RHS of any production or no adjacent non terminals is called operator  grammar.
Example: 	E EAE | (E) | id
		A + | * | -
Above grammar is not operator grammar because right side EAE has consecutive non terminals.
In operator precedence parsing we define following disjoint relations:

	Relation 	Meaning

	a<.b	a “yields precedence to” b

	a=b	a “has the same precedence as” b

	a.>b	a “takes precedence over” b




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Precedence & associativity of operators
	Operator	Precedence	Associative
	↑	1	right 
	*, /	2	left
	+, -	3	left




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Steps of operator precedence parsing
Find Leading and trailing of non terminal
Establish relation
Creation of table
Parse the string




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Leading & Trailing
Leading:- Leading of a non terminal is the first terminal or operator in production of that non terminal.
Trailing:- Trailing of a non terminal is the last terminal or operator in production of that non terminal.
Example: 	EE+T | T
		TT*F | F
		Fid

	Non terminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}










Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Rules to establish a relation
For a = b, , where  is  or a single non terminal  [e.g : (E)]
a <.b [e.g : +T]
a .>b [e.g : E+]
$ <. Leading (start symbol)
Trailing (start symbol) .> $ 




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Operator precedence parsing






a <.b




	Nonterminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}

Step 1: Find Leading & Trailing of NT 
Step 2: Establish Relation 
E E	
Step3: Creation of Table 
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				

















 +T	
| T	
T T
*F	
| F	
F id



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Operator precedence parsing






a .>b




	Nonterminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}

Step2: Establish Relation 
E 
Step3: Creation of Table 
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				














 E+
T| T	
T 
T*	
F| F	
F id
Step 1: Find Leading & Trailing of NT 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Operator precedence parsing

	Nonterminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}

Step 2: Establish Relation 
E 
Step 3: Creation of Table 
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				






 E+
T| T	
T 
T*	
F| F	
F id



Step 1: Find Leading & Trailing of NT 
$<. Leading (start symbol)
$ <. 
Trailing (start symbol) .> $ 




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Operator precedence parsing

Assign precedence operator between terminals
String:  id+id*id	
$ id+id*id $
$ <. id+id*id$
$ <. id .> +id*id$
$ <. id .> + <.  id*id$
$ <. id .> + <.  id .> *id$
$ <. id .> + <.  id .> *<. id$
$ <. id .> + <.  id .> *<. id .> $

	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

Step 4: Parse the string using precedence table 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: Operator precedence parsing
	$ <. Id .> + <. Id .> * <. Id .> $	Handle id is obtained between <. and .>
Reduce this by Fid

	$ F + <. Id .> * <. Id .> $	Handle id is obtained between <. and .>
Reduce this by Fid

	$ F + F * <. Id .> $	Handle id is obtained between <. and .>
Reduce this by Fid

	$ F + F * F $	Perform appropriate reductions of all nonterminals.

	$ E + T * F $	Remove all non terminals.

	$  +  *  $	Place relation between  operators

	$ <. + <. * >$	The * operator is surrounded by <. and .>. This indicates * becomes handle so reduce by TT*F.

	$ <. + >$	+ becomes handle. Hence reduce by EE+T. 


	$  $	Parsing Done










Step 4: Parse the string using precedence table 
Scan the input string until first .> is encountered.
Scan backward until <. is encountered.
The handle is string between <. and  .>



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
Algorithm for constructing precedence functions
Create functions  and  for each  that is terminal or .
Partition the symbols in as many as groups possible, in such a way that  and  are in the same group if .
Create a directed graph whose nodes are in the groups, next for each symbols do: 
if , place an edge from the group of  to the group of 
if , place an edge from the group of  to the group of 
If the constructed graph has a cycle then no precedence functions exist. When there are no cycles collect the length of the longest paths from the groups of  and respectively.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
Create functions fa and ga for each a that is terminal or $.
	
				

	E E+T | T
	T T*F | F	F id
f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
Partition the symbols in as many as groups possible, in such a way that fa and gb are in the same group if a = b.

f+
f*
fid
f$
g+
g*
gid
g$
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				

.



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
if a <· b, place an edge from the group of gb to the group of fa 
  if a ·> b, place an edge from the group of fa to the group of gb


f+
f*
fid
f$
g+
g*
gid
g$
f+ .> g+
f+  g+
f* .> g+
f*  g+
fid .> g+
fid  g+
f$ <. g+
f$  g+
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				

f
g



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
if a <· b, place an edge from the group of gb to the group of fa 
  if a ·> b, place an edge from the group of fa to the group of gb


f+
f*
fid
f$
g+
g*
gid
g$
f+ <. g*
f+  g*
f* .> g*
f*  g*
fid .> g*
fid  g*
f$ <. g*
f$  g*
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				

f
g



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
if a <· b, place an edge from the group of gb to the group of fa 
  if a ·> b, place an edge from the group of fa to the group of gb

f+
f*
fid
f$
g+
g*
gid
g$
f+ <. gid
f+  gid
f* <. gid
f*  gid
f$ <. gid
f$  gid
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				

f
g



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
if a <· b, place an edge from the group of gb to the group of fa 
  if a ·> b, place an edge from the group of fa to the group of gb

f+
f*
fid
g+
g*
gid
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	 	.>
	$	<.	<.	<.	 

	 				

	 				

	 				

f+ <. g$
f+  g$
f* <. g$
f*  g$
fid <. g$
fid  g$
f
g
f$
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
	 	+	*	id	$

	f 	2			

	 g				


f+
f*
fid
f$
g+
g*
gid
g$
If the constructed graph has a cycle then no precedence functions exist. When there are no cycles collect the length of the longest paths from the groups of fa and gb respectively.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
	 	+	*	id	$

	f 	2			

	 g	1			


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
	 	+	*	id	$

	f 	2	4		

	 g	1			


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function

	 	+	*	id	$

	f 	2	4		

	 g	1	3		


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
	 	+	*	id	$

	f 	2	4	4	

	 g	1	3		


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function
	 	+	*	id	$

	f 	2	4	4	

	 g	1	3	5	


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Operator precedence function

	 	+	*	id	$

	f 	2	4	4	0

	 g	1	3	5	0

f+
f*
fid
f$
g+
g*
gid
g$





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

LR parser
LR parsing is most efficient method of bottom up parsing which can be used to parse large class of context free grammar.
The technique is called LR(k) parsing:  
The “L” is for left to right scanning of input symbol, 
The “R” for constructing right most derivation in reverse, 
The “k” for the number of input symbols of look ahead that are used in making parsing decision.

LR parsing program
INPUT
OUTPUT
	a	+	b	$	

	X
	Y
	Z
	$

Parsing Table
Action
Goto



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Computation of closure & go to function
X Xb 
Closure(I):
		X  X b
Goto(I,X)
		X X b	

.
.



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Steps to construct SLR parser
Construct Canonical set of LR(0) items
Construct SLR parsing table
Parse the input string




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: SLR(1)- simple LR
S  AA
A  aA | b
S’.S
S. AA
A. aA
A. b

S’ S.

S A . A
A. aA
A. b

A. aA
A. b

A a . A
A b.

A. aA
A. b

A a . A
A b.

A. aA
A. b

A a . A
A b.

S AA .

A aA .




3
6
5
3
3
4
4
4










Augmented grammar

LR(0) item set 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Rules to construct SLR parsing table
Construct , the collection of sets of LR(0) items for 
Stateis constructed from . The parsing actions for state  are determined as follow :
If is in  and GOTO  , then set to “shift j”. Here a must be terminal.
If is in , then set to “reduce A ” for all a in ; here A may not be S’.
If is in , then set action to “accept”. 
The goto transitions for state i are constructed for all non terminals A using the
All entries not defined by rules 2 and 3 are made error.





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: SLR(1)- simple LR
		Action			Go to	
	Item
set	a	b	$	S	A
	0	S3 	S4		1	2
	1			Accept 		
	2	S3 	S4 			5
	3	S3 	S4 			6
	4	R3 	R3	R3		
	5			R1 		
	6	R2 	R2 	R2 		

S’. S
S. AA
A. aA
A. b

S’ S.

S A . A
A. aA
A. b

A. aA
A. b

A a . A
A b.

A. aA
A. b

A a . A
A b.

A. aA
A. b

A a . A
A b.

S AA .

A aA .




3
6
5
3
3
4
4
4










S  AA
A  aA | b























Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

How to calculate look ahead?
How to calculate look ahead?
SCC
C cC | d
Closure(I)
	S’.S,$
	S.CC,
	C.cC,
	C.d,


	S’			.	S		,	$
	A			.	X		,	




$
	S			.	C	C	,	$
	A			.	X		,	




c|d
c|d



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: CLR(1)- canonical LR
S  AA
A  aA | b
S’.S,$
S.AA,$

A.aA, a|b
A.b, a|b

S’ S., $

S A.A,$
A.aA, $
A. b, $

A.aA ,a|b
A. b, a|b 

Aa.A, a|b
A b., a|b

A. aA,$
A. b, $

A a.A,$
A b. ,$

A.aA , a|b
A.b , a|b

A a.A , a|b
A b., a|b

S AA. ,$ 

A aA.,a|b




3
8
5
6
3
7
4
4










Augmented grammar
A aA.,$

9
A. aA,$
A. b, $

A a.A,$
A b. ,S

6
7




LR(1) item set 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: CLR(1)- canonical LR
S  AA
A  aA | b
S’.S,$
S.AA,$

A.aA, a|b
A.b, a|b

S’ S., $

S A.A,$
A.aA, $
A. b, $

A.aA ,a|b
A. b, a|b 

Aa.A, a|b
A b., a|b

A. aA,$
A. b, $

A a.A,$
A b. ,S

A.aA , a|b
A.b , a|b

A a.A , a|b
A b., a|b

S AA. ,$ 

A aA.,a|b




3
8
5
6
3
7
4
4










A aA.,$

9
	Item set	Action			Go to	
		a	b	$	S	A
	0	S3	S4		1	2
	1			Accept		
	2	S6	S7			5
	3	S3	S4			8
	4	R3	R3			
	5			R1		
	6	S6	S7			9
	7			R3		
	8	R2	R2			
	9			R2		

A. aA,$
A. b, $

A a.A,$
A b. ,S

6
7



























Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

A aA.,a|b
Example: LALR(1)- look ahead LR
S  AA
A  aA | b
S’.S,$
S.AA,$

A.aA, a|b
A.b, a|b

S’ S., $

S A.A,$
A.aA, $
A. b, $

A.aA ,a|b
A. b, a|b 

Aa.A, a|b
A b., a|b

A. aA,$
A. b, $

A a.A,$
A b. ,$

A.aA , a|b
A.b , a|b

A a.A , a|b
A b., a|b

S AA. ,$ 





3
8
5
6
3
7
4
4










A aA.,$

9
A. aA,$
A. b, $

A a.A,$
A b. ,$

6
7






















CLR

36
A.aA , a|b|$
A. b, a|b|$ 
Aa.A, a|b|$
A b., a|b|$

47
A aA.,a|b|$

89



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Example: LALR(1)- look ahead LR

	Item set	Action			Go to	
		a	b	$	S	A
	0	S3	S4		1	2
	1			Accept		
	2	S6	S7			5
	3	S3	S4			8
	4	R3	R3			
	5			R1		
	6	S6	S7			9
	7			R3		
	8	R2	R2			
	9			R2		


	Item set	Action			Go to	
		a	b	$	S	A
	0	S36	S47		1	2
	1			Accept		
	2	S36	S47			5
	36	S36	S47			89
	47	R3	R3	R3 		
	5			R1		
	89	R2	R2	R2 		
						

CLR Parsing Table
LALR Parsing Table




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (I)
‹#›

Thank You 





































/docProps/thumbnail.jpeg

