








































PowerPoint Presentation

Unit â€“ 3
Parsing Theory (I)
dixita.kagathara@darshan.ac.in
+91 - 97277 47317 (CE Department)
Computer Engineering Department
Prof. Dixita B. Kagathara
Compiler Design (CD)
GTU # 2170701


Darshan Institute of Engineering & Technology, Rajkot



ï
Looping
Topics to be covered 
Role of parser
Context free grammar
Derivation & Ambiguity
Left recursion & Left factoring
Classification of parsing
Backtracking
LL(1) parsing
Recursive descent paring
Shift reduce parsing
Operator precedence parsing
LR parsing












Role of Parser







Role of parser

Parser obtains a string of token from the lexical analyzer and reports  syntax error if any otherwise generates syntax tree.
There are two types of parser:
 Top-down parser
 Bottom-up parser

Rest of front end
Parse tree
Token
IR
Lexical analyzer
Symbol table
Parser
Get next token
Source program
Parsetree



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Context free grammar







Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and itâ€™s a start symbol,
 is a finite set formulas of the form  where  and 


Nonterminal symbol: 
The name of syntax category of a language, e.g., noun, verb, etc. 
The It is written as a single capital letter, or as a name enclosed between < â€¦ >, e.g., A or <Noun>


<Noun Phrase> â†’ <Article><Noun>
<Article> â†’ a | an | the
<Noun> â†’ boy | apple






Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and itâ€™s a start symbol,
 is a finite set formulas of the form  where  and 


Terminal symbol: 
A symbol in the alphabet. 
It is denoted by lower case letter and punctuation marks used in language.


<Noun Phrase> â†’ <Article><Noun>
<Article> â†’ a | an | the
<Noun> â†’ boy | apple








Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and itâ€™s a start symbol,
 is a finite set formulas of the form  where  and 


Start symbol: 
First nonterminal symbol of the grammar is called start symbol. 


<Noun Phrase> â†’ <Article><Noun>
<Article> â†’ a | an | the
<Noun> â†’ boy | apple




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Context free grammar
A context free grammar (CFG) is a 4-tuple where,
 is finite set of non terminals,
 is disjoint finite set of terminals,
 is an element of  and itâ€™s a start symbol,
 is a finite set formulas of the form  where  and 


Production:  
A production, also called a rewriting rule, is a rule of grammar. It has the form of
A nonterminal symbol â†’ String of terminal and nonterminal symbols
 


<Noun Phrase> â†’ <Article><Noun>
<Article> â†’ a | an | the
<Noun> â†’ boy | apple






Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Grammar
Write terminals, non terminals, start symbol, and productions for following grammar.
E ïƒ  E O E| (E) | -E | id
O ïƒ  + | - | * | /  | â†‘

Terminals: 	id + - * / â†‘ ( )
Non terminals: E, O
Start symbol: 	E
Productions: 	E ïƒ  E O E| (E) | -E | id
		O ïƒ  + | - | * | /  | â†‘




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Derivation & Ambiguity







Derivation
Derivation is used to find whether the string belongs to a given grammar or not.
Types of derivations are:
 Leftmost derivation
 Rightmost derivation




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Leftmost derivation 
A derivation of a string  in a grammar  is a left most derivation if at every step the left most non terminal is replaced.
Grammar: Sïƒ S+S | S-S | S*S | S/S | a 	Output string: a*a-a


		S
	ïƒ S-S
ïƒ S*S-S
ïƒ a*S-S
ïƒ a*a-S
	ïƒ a*a-a


a
S
-
S
a
a
S
*
S
S
Parse tree represents the structure of derivation  
Leftmost Derivation
Parse tree



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Rightmost derivation 
A derivation of a string  in a grammar  is a right most derivation if at every step the right most non terminal is replaced.
It is all called canonical derivation.
Grammar: Sïƒ S+S | S-S | S*S | S/S | a 	Output string: a*a-a


         S
		ïƒ S*S
		 ïƒ S*S-S
		 ïƒ S*S-a
		 ïƒ S*a-a
		 ïƒ a*a-a

a
S
*
S
a
a
S
-
S
S
Rightmost Derivation
Parse Tree



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Exercise: Derivation
Perform leftmost derivation and draw parse tree.
	Sïƒ A1B
Aïƒ 0A | ğœ–
Bïƒ 0B | 1B | ğœ– 
Output string: 1001
Perform leftmost derivation and draw parse tree.
      Sïƒ 0S1 | 01   Output string: 000111
Perform rightmost derivation and draw parse tree.
Eïƒ E+E | E*E | id | (E) | -E
Output string: id + id * id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Ambiguous grammar







Ambiguity
Ambiguity, is a word, phrase, or statement which contains more than one meaning.

Chip
A long thin piece of potato
A small piece of silicon





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Ambiguity
In formal language grammar, ambiguity would arise if identical string can occur on the RHS of two or more productions.
Grammar:
	
	
 can be derived from either N1 or N2




Replaced by
 or  ?



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Ambiguous grammar
Ambiguous grammar is one that produces more than one leftmost or more then one rightmost derivation for the same sentence.
Grammar: Sïƒ S+S | S*S | (S) | a		Output string: a+a*a

	    S					   	    S
	ïƒ S*S						ïƒ S+S
	ïƒ S+S*S					ïƒ a+S
	ïƒ a+S*S					ïƒ a+S*S
	ïƒ a+a*S					ïƒ a+a*S
	ïƒ a+a*a					ïƒ a+a*a
Here, Two leftmost derivation for string a+a*a is possible hence, above grammar is ambiguous.

a
S
*
S
a
a
S
S
+
S
a
S
+
S
a
a
S
*
S
S



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Exercise: Ambiguous Grammar
Check Ambiguity in following grammars:
Sïƒ  aS | Sa | ğœ–  (output string: aaaa)
Sïƒ  aSbS | bSaS | ğœ–  (output string: abab)
Sïƒ  SS+ | SS* | a (output string: aa+a*)
<exp> â†’ <exp> + <term> | <term>
<term> â†’ <term> * <letter> | <letter> 
<letter> â†’ a|b|c|â€¦|z  (output string: a+b*c) 
Prove that the CFG with productions: S ïƒ  a | Sa | bSS | SSb | SbS  is ambiguous (Hint: consider output string yourself)




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Left recursion & Left factoring







Left recursion
A grammar is said to be left recursive if it has a non terminal  such that there is a derivation for some string 
Algorithm to eliminate left recursion
Arrange the non terminals in some orderÂ Â 
For Â do begin
	forÂ Â do begin
Â 		replace each production of the formÂ Â  
			by the productions ,
			where are all the current 				productions;
Â 	Â end
Â 	 eliminate the immediate left recursion among theÂ  - productions
end




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º



Left recursion elimination

  

ïƒ 


ğœ–



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Examples: Left recursion elimination
Eïƒ E+T | T
				Eïƒ TEâ€™
				Eâ€™ïƒ +TEâ€™ | Îµ
Tïƒ T*F | F
				Tïƒ FTâ€™
				Tâ€™ïƒ *FTâ€™ | Îµ 
Xïƒ X%Y | Z
				Xïƒ ZXâ€™
				Xâ€™ïƒ %YXâ€™ | Îµ 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Exercise: Left recursion
Aïƒ Abd | Aa | a
       Bïƒ Be | b
Aïƒ AB | AC | a | b
Sïƒ A | B
Aïƒ ABC | Acd | a | aa
Bïƒ Bee | b
Expïƒ Exp+term | Exp-term | term





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Left factoring
Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive parsing.
Algorithm to left factor a grammar
Input: Grammar G
Output: An equivalent left factored grammar.
Method: 
For each non terminal A find the longest prefixÂ Â common to two or more of its alternatives. IfÂ , i.e.,Â Â there is a non trivial common prefix, replace all the  productions whereÂ Â represents all alternatives that do not begin withÂ Â by
	 

Here A' is new non terminal. Repeatedly apply this transformation until no two alternatives for a non-terminal have a common prefix.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º




Î´
Left factoring elimination
  

Î´


|
  
  
  



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Left factoring elimination
Sïƒ aAB | aCD
			Sïƒ aSâ€™
			Sâ€™ïƒ AB | CD
Aïƒ  xByA | xByAzA | a

			Aïƒ  xByAAâ€™ | a
			Aâ€™ïƒ  Ğ„ | zA 
Aïƒ  aAB | aA |a
			Aïƒ aAâ€™
			Aâ€™ïƒ AB | A | ğœ–
			Aâ€™ïƒ AAâ€™â€™ | ğœ–
			Aâ€™â€™ïƒ B | ğœ– 




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Exercise
Sïƒ iEtS | iEtSeS | a
Aïƒ  ad | a | ab | abc | x




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing







Parsing
Parsing is a technique that takes input string and produces output either a parse tree if string is valid sentence of grammar, or an error message indicating that string is not a valid.
Types of parsing are:
Top down parsing: In top down parsing parser build parse tree from top to bottom.
Bottom up parsing: Bottom up parser starts from leaves and work up to the root.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Classification of parsing methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Backtracking
In backtracking, expansion of nonterminal symbol we choose one alternative and if any mismatch occurs then we try another alternative. 
Grammar: Sïƒ  cAd		Input string: cad
	        Aïƒ  ab | a
c
A
d
S
c
A
d
S
a
b
c
A
d
S
a
Parsing done
Make prediction
Backtrack
Make prediction



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Exercise
Eïƒ  5+T | 3-T
Tïƒ  V | V*V | V+V
Vïƒ  a | b
String: 3-a+b




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

LL(1) parser (predictive parser)
LL(1) is non recursive top down parser.
First L indicates input is scanned from left to right. 
The second L means it uses leftmost derivation for input string 
 1 means it uses only input symbol to predict the parsing process.

Predictive parsing program
Parsing table M
INPUT
OUTPUT
  Stack 
	a	+	b	$	

	X
	Y
	Z
	$




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

LL(1) parsing (predictive parsing)
Steps to construct LL(1) parser
Remove left recursion / Perform left factoring (if any).
Compute FIRST and FOLLOW of non terminals.
Construct predictive parsing table.
Parse the input string using parsing table.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Rules to compute first of non terminal
If and  is terminal, add  to .
If , add to .
If  is nonterminal and is a production, then place  in  if for some , a is in , and ğœ– is in all of that is . If ğœ– is in  for all then add ğœ– to .
Everything in  is surely in  If  does not derive ğœ–, then we do nothing more to , but if , then we add  and so on.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Rules to compute first of non terminal
Simplification of Rule 3
If  , 
 If  does not derives 
 If  derives 
 
 If  & Y2 derives âˆˆ
 
If  , Y2 & Y3 derives âˆˆ

If  , Y2 , Y3 â€¦..YK all derives âˆˆ 
(note: if all non terminals derives âˆˆ then add âˆˆ to FIRST(A))




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Rules to compute FOLLOW of non terminal
Place S is start symbol)
If then everything in  except for ğœ– is placed in  
If there is a production or a production  where  contains  then everything in 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

How to apply rules to find FOLLOW of non terminal?







 ğœ–
 ğœ–





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Rules to construct predictive parsing table
For each production  of the grammar, do steps 2 and 3.
For each terminal  in , Add  to .
If  is in , Add  to  for each terminal  in . If  is in , and  is in , add  to .
Make each undefined entry of M be error.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-1: LL(1) parsing


Step 1: Not required 
Step 2: Compute FIRST
First(S)
Sïƒ aBa

First(B)
Bïƒ bB 					Bïƒ ğœ–

Sïƒ aBa
	Bïƒ bB | Ïµ
	
	S	ïƒ 	a	B	a

	A	ïƒ 	

	B	ïƒ 	ğœ–

	A	ïƒ 	

Rule 1
add  to 
Rule 2
add  to 
FIRST(B)={ b 
 , ğœ– }
	NT	First

	S	{ a }

	B	{b,ğœ–}


	B	ïƒ 	b	B

	A	ïƒ 	

Rule 1
add  to 

FIRST(S)={ a } 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-1: LL(1) parsing


Step 2: Compute FOLLOW
Follow(S)


Follow(B)
Sïƒ aBa 				Bïƒ bB 

Sïƒ aBa
	Bïƒ bB | Ïµ
	
Follow(B)={ a  
	B	ïƒ 	b	B

Follow(S)={ $ } 
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{a}

	S	ïƒ 	a	B	a

	A 	ïƒ 		B

Rule 3
Follow(A)=follow(B)
	A	ïƒ 		B	

Rule 2
First(


Rule 1: Place $ in FOLLOW(S)


 }



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-1: LL(1) parsing


Step 3: Prepare predictive parsing table





Sïƒ aBa
a=FIRST(aBa)={ a }
M[S,a]=Sïƒ aBa

Sïƒ aBa
	Bïƒ bB | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{a}

	NT	Input Symbol		
		a	b	$
	S	Sïƒ aBa		
	B			

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-1: LL(1) parsing


Step 3: Prepare predictive parsing table





Bïƒ bB
a=FIRST(bB)={ b }
M[B,b]=Bïƒ bB

Sïƒ aBa
	Bïƒ bB | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{a}

	NT	Input Symbol		
		a	b	$
	S	Sïƒ aBa		
	B		Bïƒ bB	

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-1: LL(1) parsing


Step 3: Prepare predictive parsing table





Bïƒ Ïµ
b=FOLLOW(B)={ a }
M[B,a]=Bïƒ ğœ–


Sïƒ aBa
	Bïƒ bB | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{a}

	NT	Input Symbol		
		a	b	$
	S	Sïƒ aBa	Error	Error
	B	Bïƒ Ïµ	Bïƒ bB	Error


Rule: 3
Aïƒ  
b = follow(A)
M[A,b] = Aïƒ  






Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 1: Not required 
Step 2: Compute FIRST
First(S)
Sïƒ aB 					Sïƒ ğœ–


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	S	ïƒ 	ğœ–

	A	ïƒ 	

Rule 2
add  to 
FIRST(S)={ a 
 , ğœ– }
	NT	First

	S	{ a, ğœ– }

	B	{b,ğœ–}


	S	ïƒ 	a	B

	A	ïƒ 	

Rule 1
add  to 
	C	{c,ğœ–}






Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 1: Not required 
Step 2: Compute FIRST
First(B)
Bïƒ bC 					Bïƒ ğœ–


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	B	ïƒ 	ğœ–

	A	ïƒ 	

Rule 2
add  to 
FIRST(B)={ b 
 , ğœ– }
	NT	First

	S	{ a, ğœ– }

	B	{b,ğœ–}

	B	ïƒ 	b	C

	A	ïƒ 	

Rule 1
add  to 
	C	{c,ğœ–}






Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 1: Not required 
Step 2: Compute FIRST
First(C)
Cïƒ cS 					Cïƒ ğœ–


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	C	ïƒ 	ğœ–

	A	ïƒ 	

Rule 2
add  to 
FIRST(B)={ c 
 , ğœ– }
	NT	First

	S	{ a, ğœ– }

	B	{b,ğœ–}

	C	ïƒ 	c	S

	A	ïƒ 	

Rule 1
add  to 
	C	{c,ğœ–}





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing
Step 2: Compute FOLLOW
Follow(S)

Cïƒ cS






Bïƒ bC 					Sïƒ aB 

 

 ={$}
	C	ïƒ 	c	S

Follow(S)={ $ } 
	NT	First 	Follow 
	S	{a,ğœ–}	{$}
	B	{b,ğœ–}	{$}
	C	{c,ğœ–}	{$}

	A 	ïƒ 		B

Rule 3
Follow(A)=follow(B)
Rule 1: Place $ in FOLLOW(S)


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
Follow(S)=Follow(C) 
	B	ïƒ 	b	C

	A 	ïƒ 		B

Rule 3
Follow(A)=follow(B)
Follow(C)=Follow(B) 
 ={$}
	S	ïƒ 	a	B

	A 	ïƒ 		B

Rule 3
Follow(A)=follow(B)
Follow(B)=Follow(S) 
 ={$}






Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





Sïƒ aB
a=FIRST(aB)={ a }
M[S,a]=Sïƒ aB

	NT	Input Symbol			
		a	b	c	$
	S	Sïƒ aB			
	B				
	C				

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  

Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	NT	First 	Follow 
	S	{a,ğœ–}	{$}
	B	{b,ğœ–}	{$}
	C	{c,ğœ–}	{$}




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





Sïƒ ğœ–
b=FOLLOW(S)={ $ }
M[S,$]=Sïƒ ğœ–

	NT	Input Symbol			
		a	b	c	$
	S	Sïƒ aB			Sïƒ ğœ–
	B				
	C				


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{$}
	C	{c,ğœ–}	{$}

Rule: 3
Aïƒ  
b = follow(A)
M[A,b] = Aïƒ  



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





Bïƒ bC
a=FIRST(bC)={ b }
M[B,b]=Bïƒ bC

	NT	Input Symbol			
		a	b	c	$
	S	Sïƒ aB			Sïƒ ğœ–
	B		Bïƒ bC		
	C				


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{$}
	C	{c,ğœ–}	{$}

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





Bïƒ ğœ–
b=FOLLOW(B)={ $ }
M[B,$]=Bïƒ ğœ–

	NT	Input Symbol			
		a	b	c	$
	S	Sïƒ aB			Sïƒ ğœ–
	B		Bïƒ bC		Bïƒ ğœ–
	C				


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{$}
	C	{c,ğœ–}	{$}

Rule: 3
Aïƒ  
b = follow(A)
M[A,b] = Aïƒ  



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





Cïƒ cS
a=FIRST(cS)={ c }
M[C,c]=Cïƒ cS

	NT	Input Symbol			
		a	b	c	$
	S	Sïƒ aB			Sïƒ ğœ–
	B		Bïƒ bC		Bïƒ ğœ–
	C			Cïƒ cS	


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{$}
	C	{c,ğœ–}	{$}

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-2: LL(1) parsing



Step 3: Prepare predictive parsing table





Cïƒ ğœ–
b=FOLLOW(C)={ $ }
M[C,$]=Cïƒ ğœ–

	NT	Input Symbol			
		a	b	c	$
	S	Sïƒ aB	Error	Error	Sïƒ ğœ–
	B	Error	Bïƒ bB	Error	Bïƒ ğœ–
	C	Error	Error	Cïƒ cS	Cïƒ ğœ–


Sïƒ aB | Ïµ
	Bïƒ bC | Ïµ
Cïƒ cS | Ïµ
	
	NT	First 	Follow 
	S	{a}	{$}
	B	{b,ğœ–}	{$}
	C	{c,ğœ–}	{$}

Rule: 3
Aïƒ  
b = follow(A)
M[A,b] = Aïƒ  









Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Eïƒ E+T | T
Tïƒ T*F | F
Fïƒ (E) | id
Step 1: Remove left recursion
	Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FIRST
First(E)
Eïƒ TEâ€™


First(T)
Tïƒ FTâ€™

First(F)
Fïƒ (E) 					Fïƒ id


Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id

	E	ïƒ 	T	Eâ€™

	A	ïƒ 	Y1	Y2

Rule 3
First(A)=First(Y1)
	T	ïƒ 	F	Tâ€™

	A	ïƒ 	Y1	Y2

Rule 3
First(A)=First(Y1)
FIRST(E)=FIRST(T)
FIRST(T)=FIRST(F)
	F	ïƒ 	(	E	)

	A	ïƒ 	

	F	ïƒ 	id

	A	ïƒ 	

Rule 1
add  to 
Rule 1
add  to 
FIRST(F)={ ( 
 , id }
	NT	First

	E	{ (,id }

	Eâ€™	

	T	{ (,id }

	Tâ€™	

	F	{ (,id }




= {(, id }
= {(, id }



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FIRST
First(Eâ€™)
Eâ€™ïƒ +TEâ€™



Eâ€™ïƒ ğœ–



	A	ïƒ 	

	Eâ€™	ïƒ 	

	A	ïƒ 	

Rule 1
add  to 
Rule 2
add  to 
FIRST(Eâ€™)={ +
, ğœ– }
	Eâ€™	ïƒ 	+	T	Eâ€™

	NT	First

	E	{ (,id }

	Eâ€™	{ +, ğœ– }

	T	{ (,id }

	Tâ€™	

	F	{ (,id }

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FIRST
First(Tâ€™)
Tâ€™ïƒ *FTâ€™



Tâ€™ïƒ ğœ–



	A	ïƒ 	

	Tâ€™	ïƒ 	

	A	ïƒ 	

Rule 1
add  to 
Rule 2
add  to 
FIRST(Tâ€™)={ *
, ğœ– }
	Tâ€™	ïƒ 	*	F	Tâ€™

	NT	First

	E	{ (,id }

	Eâ€™	{ +, ğœ– }

	T	{ (,id }

	Tâ€™	{ *, ğœ– }

	F	{ (,id }

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(E)

Fïƒ (E)
	


	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	

	T	{ (,id }	

	Tâ€™	{ *, ğœ– }	

	F	{ (,id }	

Rule 1: Place $ in FOLLOW(E)
FOLLOW(E)={ $,
	F 	ïƒ 	(	E	)

	A 	ïƒ 		B	

Rule 2

) }

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(Eâ€™)
Eïƒ TEâ€™



Eâ€™ïƒ +TEâ€™
	

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	

	Tâ€™	{ *, ğœ– }	

	F	{ (,id }	

FOLLOW(Eâ€™)={ $,)
	E 	ïƒ 	T	Eâ€™

	A 	ïƒ 		B

Rule 3


	Eâ€™	ïƒ 	+T	Eâ€™

	A 	ïƒ 		B

Rule 3

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id

}



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(T)
Eïƒ TEâ€™



	

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	

	Tâ€™	{ *, ğœ– }	

	F	{ (,id }	

FOLLOW(T)={ +,
	E 	ïƒ 		T	Eâ€™

	A 	ïƒ 		B	

$, ) 
	E	ïƒ 		T	Eâ€™

	A 	ïƒ 		B	

Rule 3

Rule 2

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(T)
Eâ€™ïƒ +TEâ€™

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	

	F	{ (,id }	

FOLLOW(T)={ +,
	Eâ€™ 	ïƒ 	+	T	Eâ€™

	A 	ïƒ 		B	

$, )

Rule 3

Rule 2

	Eâ€™ 	ïƒ 	+	T	Eâ€™

	A 	ïƒ 		B	

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id

} 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(Tâ€™)
Tïƒ FTâ€™



Tâ€™ïƒ *FTâ€™
	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	

FOLLOW(Tâ€™)={+ $,)
	T	ïƒ 	F	Tâ€™

	A 	ïƒ 		B

Rule 3


	Tâ€™	ïƒ 	*F	Tâ€™

	A 	ïƒ 		B

Rule 3

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id

}



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(F)
Tïƒ FTâ€™

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	

FOLLOW(F)={ *,
	T 	ïƒ 		F	Tâ€™

	A 	ïƒ 		B	

 + ,$ , ) 
	T	ïƒ 		F	Tâ€™

	A 	ïƒ 		B	

Rule 3

Rule 2

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 2: Compute FOLLOW
FOLLOW(F)
Tâ€™ïƒ *FTâ€™



	


	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

FOLLOW(F)={ *,+,
	Tâ€™ 	ïƒ 	*	F	Tâ€™

	A 	ïƒ 		B	

$, )

Rule 3

Rule 2

	Tâ€™ 	ïƒ 	*	F	Tâ€™

	A 	ïƒ 		B	

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id

} 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







Eïƒ TEâ€™
a=FIRST(TEâ€™)={ (,id }
M[E,(]=Eïƒ TEâ€™
M[E,id]=Eïƒ TEâ€™

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  
	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™						
	T						
	Tâ€™						
	F						



Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







Eâ€™ïƒ +TEâ€™
a=FIRST(+TEâ€™)={ + }
M[Eâ€™,+]=Eâ€™ïƒ +TEâ€™

	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™		Eâ€™ïƒ +TEâ€™				
	T						
	Tâ€™						
	F						

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







Eâ€™ïƒ ğœ–
b=FOLLOW(Eâ€™)={ $,) }
M[Eâ€™,$]=Eâ€™ïƒ ğœ–
M[Eâ€™,)]=Eâ€™ïƒ ğœ–

	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™		Eâ€™ïƒ +TEâ€™			Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T						
	Tâ€™						
	F						

Rule: 3
Aïƒ  
b = follow(A)
M[A,b] = Aïƒ  


	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







Tïƒ FTâ€™
a=FIRST(FTâ€™)={ (,id }
M[T,(]=Tïƒ FTâ€™
M[T,id]=Tïƒ FTâ€™


	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™		Eâ€™ïƒ +TEâ€™			Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T	Tïƒ FTâ€™			Tïƒ FTâ€™		
	Tâ€™						
	F						



	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table







Tâ€™ïƒ *FTâ€™
a=FIRST(*FTâ€™)={ * }
M[Tâ€™,*]=Tâ€™ïƒ *FTâ€™

	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™		Eâ€™ïƒ +TEâ€™			Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T	Tïƒ FTâ€™			Tïƒ FTâ€™		
	Tâ€™			Tâ€™ïƒ *FTâ€™			
	F						

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table






Tâ€™ïƒ ğœ–
b=FOLLOW(Tâ€™)={ +,$,) }
M[Tâ€™,+]=Tâ€™ïƒ ğœ–
M[Tâ€™,$]=Tâ€™ïƒ ğœ–
M[Tâ€™,)]=Tâ€™ïƒ ğœ–

	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™		Eâ€™ïƒ +TEâ€™			Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T	Tïƒ FTâ€™			Tïƒ FTâ€™		
	Tâ€™		Tâ€™ïƒ ğœ–	Tâ€™ïƒ *FTâ€™		Tâ€™ïƒ ğœ–	Tâ€™ïƒ ğœ–
	F						

Rule: 3
Aïƒ  
b = follow(A)
M[A,b] = Aïƒ  



	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table








Fïƒ (E)
a=FIRST((E))={ ( }
M[F,(]=Fïƒ (E)

	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™		Eâ€™ïƒ +TEâ€™			Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T	Tïƒ FTâ€™			Tïƒ FTâ€™		
	Tâ€™		Tâ€™ïƒ ğœ–	Tâ€™ïƒ *FTâ€™		Tâ€™ïƒ ğœ–	Tâ€™ïƒ ğœ–
	F				Fïƒ (E)		

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 3: Construct predictive parsing table








Fïƒ id
a=FIRST(id)={ id }
M[F,id]=Fïƒ id

	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™			Eïƒ TEâ€™		
	Eâ€™		Eâ€™ïƒ +TEâ€™			Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T	Tïƒ FTâ€™			Tïƒ FTâ€™		
	Tâ€™		Tâ€™ïƒ ğœ–	Tâ€™ïƒ *FTâ€™		Tâ€™ïƒ ğœ–	Tâ€™ïƒ ğœ–
	F	Fïƒ id			Fïƒ (E)		

Rule: 2
Aïƒ  
a = first()
M[A,a] = Aïƒ  

	NT	First	Follow

	E	{ (,id }	{ $,) }

	Eâ€™	{ +, ğœ– }	{ $,) }

	T	{ (,id }	{ +,$,) }

	Tâ€™	{ *, ğœ– }	{ +,$,) }

	F	{ (,id }	{*,+,$,)}

Eïƒ TEâ€™
	Eâ€™ïƒ +TEâ€™ | Ïµ
	Tïƒ FTâ€™
	Tâ€™ïƒ *FTâ€™ | Ïµ
	Fïƒ (E) | id




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 4: Make each undefined entry of table be Error

	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™	Error	Error	Eïƒ TEâ€™	Error	Error
	Eâ€™	Error	Eâ€™ïƒ +TEâ€™	Error	Error	Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T	Tïƒ FTâ€™	Error	Error	Tïƒ FTâ€™	Error	Error
	Tâ€™	Error	Tâ€™ïƒ ğœ–	Tâ€™ïƒ *FTâ€™	Error	Tâ€™ïƒ ğœ–	Tâ€™ïƒ ğœ–
	F	Fïƒ id	Error	Error	Fïƒ (E)	Error	Error




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example-3: LL(1) parsing
Step 4: Parse the string : id + id * id $

	STACK	INPUT	OUTPUT

	E$	id+id*id$	

	TEâ€™$	id+id*id$	Eïƒ TEâ€™

	FTâ€™Eâ€™$	id+id*id$	Tïƒ FTâ€™

	idTâ€™Eâ€™$	id+id*id$	Fïƒ id

	Tâ€™Eâ€™$	+id*id$	

	+TEâ€™$	+id*id$	Eâ€™ïƒ +TEâ€™

	Eâ€™$	+id*id$	Tâ€™ïƒ ğœ–

	idTâ€™Eâ€™$	id$	Fïƒ id

	TEâ€™$	id*id$	

	Tâ€™Eâ€™$	$	

	FTâ€™Eâ€™$	id*id$	Tïƒ FTâ€™

	Eâ€™$	$	Tâ€™ïƒ ğœ–

	FTâ€™Eâ€™$	id$	

	$	$	Eâ€™ïƒ ğœ–

	*FTâ€™Eâ€™$	*id$	Tïƒ *FTâ€™

	Tâ€™Eâ€™$	*id$	

	idTâ€™Eâ€™$	id*id$	Fïƒ id













































	NT	Input Symbol					
		id	+	*	(	)	$
	E	Eïƒ TEâ€™	Error	Error	Eïƒ TEâ€™	Error	Error
	Eâ€™	Error	Eâ€™ïƒ +TEâ€™	Error	Error	Eâ€™ïƒ ğœ–	Eâ€™ïƒ ğœ–
	T	Tïƒ FTâ€™	Error	Error	Tïƒ FTâ€™	Error	Error
	Tâ€™	Error	Tâ€™ïƒ ğœ–	Tâ€™ïƒ *FTâ€™	Error	Tâ€™ïƒ ğœ–	Tâ€™ïƒ ğœ–
	F	Fïƒ id	Error	Error	Fïƒ (E)	Error	Error




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Recursive descent parsing
A top down parsing that executes a set of recursive procedure to process the input without backtracking is called recursive descent parser.
There is a procedure for each non terminal in the grammar.
Consider RHS of any production rule as definition of the procedure.
As it reads expected input symbol, it advances input pointer to next position.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Recursive descent parsing
Procedure E
{
	If lookahead=num 
	{
		Match(num);
		T();
	}
	Else
		Error();
	If lookahead=$
	{
		Declare success;
	}
	Else
		Error();
}

Procedure T
{
	If lookahead=â€™*â€™ 
	{
		Match(â€˜*â€™);
		If lookahead=num 
		{
			Match(num);
			T();
		}
		Else
			Error();
Â 
	}
	Else
		NULL
}
Proceduce Match(token t)
{
	If lookahead=t
	lookahead=next_token;
	Else
		Error();
}
Procedure Error
{
	Print(â€œErrorâ€);
}
	
	Eïƒ  
	Tïƒ 
	3	*	4	$


num
T
num
*
T
| ğœ–

Success



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Recursive descent parsing
Procedure E
{
	If lookahead=num 
	{
		Match(num);
		T();
	}
	Else
		Error();
	If lookahead=$
	{
		Declare success;
	}
	Else
		Error();
}

Procedure T
{
	If lookahead=â€™*â€™ 
	{
		Match(â€˜*â€™);
		If lookahead=num 
		{
			Match(num);
			T();
		}
		Else
			Error();
Â 
	}
	Else
		NULL
}
Proceduce Match(token t)
{
	If lookahead=t
	lookahead=next_token;
	Else
		Error();
}
Procedure Error
{
	Print(â€œErrorâ€);
}
	
	Eïƒ  
	Tïƒ 
num
T
num
*
T
| ğœ–
Success
	3	4	*	$

Error
	3	*	4	$




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Handle & Handle pruning
Handle: A â€œhandleâ€ of a string is a substring of the string that matches the right side of a production, and whose reduction to the non terminal of the production is one step along the reverse of rightmost derivation.
Handle pruning: The process of discovering a handle and reducing it to appropriate left hand side non terminal is known as handle pruning.

Eïƒ E+E
Eïƒ E*E
Eïƒ id
String: id1+id2*id3
	Right sentential form	Handle	Production

	id1+id2*id3	id1	Eïƒ id 

	E+id2*id3	id2	Eïƒ id

	E+E*id3	id3	Eïƒ id

	E+E*E	E*E	Eïƒ E*E

	E+E	E+E	Eïƒ E+E 

	E		
















Rightmost Derivation
E
E+E
E+E*E
E+E*id3
E+id2*id3
id1+id2*id3



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Shift reduce parser
The shift reduce parser performs following basic operations:
Shift: Moving of the symbols from input buffer onto the stack, this action is called shift.
Reduce: If handle appears on the top of the stack then reduction of it by appropriate rule is done. This action is called reduce action.
Accept: If stack contains start symbol only and input buffer is empty at the same time then that action is called accept.
Error: A situation in which parser cannot either shift or reduce the symbols, it cannot even perform accept action then it is called error action.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Shift reduce parser
	Stack 	Input Buffer	Action

	$	id+id*id$	Shift 


	$id	+id*id$	Reduce Fïƒ id

	$F	+id*id$	Reduce Tïƒ F

	$T	+id*id$	Reduce Eïƒ T

	$E	+id*id$	Shift 

	$E+	id*id$	Shift 

	$E+id	*id$	Reduce Fïƒ id

	$E+F	*id$	Reduce Tïƒ F

	$E+T	*id$	Shift 

	$E+T*	id$	Shift 

	$E+T*id	$	Reduce Fïƒ id 

	$E+T*F	$	Reduce Tïƒ T*F 

	$E+T	$	Reduce Eïƒ E+T

	$E	$	Accept 













































Grammar:
Eïƒ E+T | T
Tïƒ T*F | F
Fïƒ id
String: id+id*id



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Viable Prefix
The set of prefixes of right sentential forms that can appear on the stack of a shift-reduce parser are called viable prefixes.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence parsing
Operator Grammar: A Grammar in which there is no Ğ„ in RHS of any production or no adjacent non terminals is called operator  grammar.
Example: 	Eïƒ  EAE | (E) | id
		Aïƒ  + | * | -
Above grammar is not operator grammar because right side EAE has consecutive non terminals.
In operator precedence parsing we define following disjoint relations:

	Relation 	Meaning

	a<.b	a â€œyields precedence toâ€ b

	a=b	a â€œhas the same precedence asâ€ b

	a.>b	a â€œtakes precedence overâ€ b




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Precedence & associativity of operators
	Operator	Precedence	Associative
	â†‘	1	right 
	*, /	2	left
	+, -	3	left




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Steps of operator precedence parsing
Find Leading and trailing of non terminal
Establish relation
Creation of table
Parse the string




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Leading & Trailing
Leading:- Leading of a non terminal is the first terminal or operator in production of that non terminal.
Trailing:- Trailing of a non terminal is the last terminal or operator in production of that non terminal.
Example: 	Eïƒ E+T | T
		Tïƒ T*F | F
		Fïƒ id

	Non terminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}










Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Rules to establish a relation
For a = b, , where  is  or a single non terminal  [e.g : (E)]
a <.b [e.g : +T]
a .>b [e.g : E+]
$ <. Leading (start symbol)
Trailing (start symbol) .> $ 




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Operator precedence parsing






a <.b




	Nonterminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}

Step 1: Find Leading & Trailing of NT 
Step 2: Establish Relation 
Eïƒ  E	
Step3: Creation of Table 
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				

















 +T	
| T	
Tïƒ  T
*F	
| F	
Fïƒ  id



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Operator precedence parsing






a .>b




	Nonterminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}

Step2: Establish Relation 
Eïƒ  
Step3: Creation of Table 
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				














 E+
T| T	
Tïƒ  
T*	
F| F	
Fïƒ  id
Step 1: Find Leading & Trailing of NT 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Operator precedence parsing

	Nonterminal 	Leading	Trailing

	E	{+,*,id}	{+,*,id}

	T	{*,id}	{*,id}

	F	{id}	{id}

Step 2: Establish Relation 
Eïƒ  
Step 3: Creation of Table 
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				






 E+
T| T	
Tïƒ  
T*	
F| F	
Fïƒ  id



Step 1: Find Leading & Trailing of NT 
$<. Leading (start symbol)
$ <. 
Trailing (start symbol) .> $ 




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Operator precedence parsing

Assign precedence operator between terminals
String:  id+id*id	
$ id+id*id $
$ <. id+id*id$
$ <. id .> +id*id$
$ <. id .> + <.  id*id$
$ <. id .> + <.  id .> *id$
$ <. id .> + <.  id .> *<. id$
$ <. id .> + <.  id .> *<. id .> $

	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

Step 4: Parse the string using precedence table 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: Operator precedence parsing
	$ <. Id .> + <. Id .> * <. Id .> $	Handle id is obtained between <. and .>
Reduce this by Fïƒ id

	$ F + <. Id .> * <. Id .> $	Handle id is obtained between <. and .>
Reduce this by Fïƒ id

	$ F + F * <. Id .> $	Handle id is obtained between <. and .>
Reduce this by Fïƒ id

	$ F + F * F $	Perform appropriate reductions of all nonterminals.

	$ E + T * F $	Remove all non terminals.

	$  +  *  $	Place relation between  operators

	$ <. + <. * >$	The * operator is surrounded by <. and .>. This indicates * becomes handle so reduce by Tïƒ T*F.

	$ <. + >$	+ becomes handle. Hence reduce by Eïƒ E+T. 


	$  $	Parsing Done










Step 4: Parse the string using precedence table 
Scan the input string until first .> is encountered.
Scan backward until <. is encountered.
The handle is string between <. and  .>



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
Algorithm for constructing precedence functions
Create functions  and  for each  that is terminal or .
Partition the symbols in as many as groups possible, in such a way that  and  are in the same group if .
Create a directed graph whose nodes are in the groups, next for each symbols do: 
if , place an edge from the group of  to the group of 
if , place an edge from the group of  to the group of 
If the constructed graph has a cycle then no precedence functions exist. When there are no cycles collect the length of the longest paths from the groups of  and respectively.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
Create functions fa and ga for each a that is terminal or $.
	
				

	Eïƒ  E+T | T
	Tïƒ  T*F | F	Fïƒ  id
f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
Partition the symbols in as many as groups possible, in such a way that fa and gb are in the same group if a = b.

f+
f*
fid
f$
g+
g*
gid
g$
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				

.



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
if a <Â· b, place an edge from the group of gb to the group of fa 
  if a Â·> b, place an edge from the group of fa to the group of gb


f+
f*
fid
f$
g+
g*
gid
g$
f+ .> g+
f+ ïƒ  g+
f* .> g+
f* ïƒ  g+
fid .> g+
fid ïƒ  g+
f$ <. g+
f$ ïƒŸ g+
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				

f
g



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
if a <Â· b, place an edge from the group of gb to the group of fa 
  if a Â·> b, place an edge from the group of fa to the group of gb


f+
f*
fid
f$
g+
g*
gid
g$
f+ <. g*
f+ ïƒŸ g*
f* .> g*
f* ïƒ  g*
fid .> g*
fid ïƒ  g*
f$ <. g*
f$ ïƒŸ g*
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				

f
g



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
if a <Â· b, place an edge from the group of gb to the group of fa 
  if a Â·> b, place an edge from the group of fa to the group of gb

f+
f*
fid
f$
g+
g*
gid
g$
f+ <. gid
f+ ïƒŸ gid
f* <. gid
f* ïƒŸ gid
f$ <. gid
f$ ïƒŸ gid
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				

f
g



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
if a <Â· b, place an edge from the group of gb to the group of fa 
  if a Â·> b, place an edge from the group of fa to the group of gb

f+
f*
fid
g+
g*
gid
	 	+	*	id	$

	+	.>	<.	<.	.>
	*	.>	.>	<.	.>
	id	.>	.>	Â 	.>
	$	<.	<.	<.	Â 

	 				

	 				

	 				

f+ <. g$
f+ ïƒ  g$
f* <. g$
f* ïƒ  g$
fid <. g$
fid ïƒ  g$
f
g
f$
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
	 	+	*	id	$

	f 	2			

	 g				


f+
f*
fid
f$
g+
g*
gid
g$
If the constructed graph has a cycle then no precedence functions exist. When there are no cycles collect the length of the longest paths from the groups of fa and gb respectively.




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
	 	+	*	id	$

	f 	2			

	 g	1			


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
	 	+	*	id	$

	f 	2	4		

	 g	1			


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function

	 	+	*	id	$

	f 	2	4		

	 g	1	3		


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
	 	+	*	id	$

	f 	2	4	4	

	 g	1	3		


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function
	 	+	*	id	$

	f 	2	4	4	

	 g	1	3	5	


f+
f*
fid
f$
g+
g*
gid
g$



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Operator precedence function

	 	+	*	id	$

	f 	2	4	4	0

	 g	1	3	5	0

f+
f*
fid
f$
g+
g*
gid
g$





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

LR parser
LR parsing is most efficient method of bottom up parsing which can be used to parse large class of context free grammar.
The technique is called LR(k) parsing:  
The â€œLâ€ is for left to right scanning of input symbol, 
The â€œRâ€ for constructing right most derivation in reverse, 
The â€œkâ€ for the number of input symbols of look ahead that are used in making parsing decision.

LR parsing program
INPUT
OUTPUT
	a	+	b	$	

	X
	Y
	Z
	$

Parsing Table
Action
Goto



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Computation of closure & go to function
Xïƒ  Xb 
Closure(I):
		Xïƒ   X b
Goto(I,X)
		Xïƒ  X b	

.
.



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Steps to construct SLR parser
Construct Canonical set of LR(0) items
Construct SLR parsing table
Parse the input string




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: SLR(1)- simple LR
S ïƒ  AA
A ïƒ  aA | b
Sâ€™ïƒ .S
Sïƒ . AA
Aïƒ . aA
Aïƒ . b

Sâ€™ïƒ  S.

Sïƒ  A . A
Aïƒ . aA
Aïƒ . b

Aïƒ . aA
Aïƒ . b

Aïƒ  a . A
Aïƒ  b.

Aïƒ . aA
Aïƒ . b

Aïƒ  a . A
Aïƒ  b.

Aïƒ . aA
Aïƒ . b

Aïƒ  a . A
Aïƒ  b.

Sïƒ  AA .

Aïƒ  aA .




3
6
5
3
3
4
4
4










Augmented grammar

LR(0) item set 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Rules to construct SLR parsing table
Construct , the collection of sets of LR(0) items for 
Stateis constructed from . The parsing actions for state  are determined as follow :
If is in Â and GOTO Â , then set to â€œshift jâ€. Here a must be terminal.
If is in , then set to â€œreduce Aïƒ  â€ for all a in ; here A may not be Sâ€™.
If is in , then set action to â€œacceptâ€. 
The goto transitions for state i are constructed for all non terminals A using the
All entries not defined by rules 2 and 3 are made error.





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: SLR(1)- simple LR
		Action			Go to	
	Item
set	a	b	$	S	A
	0	S3 	S4		1	2
	1			Accept 		
	2	S3 	S4 			5
	3	S3 	S4 			6
	4	R3 	R3	R3		
	5			R1 		
	6	R2 	R2 	R2 		

Sâ€™ïƒ . S
Sïƒ . AA
Aïƒ . aA
Aïƒ . b

Sâ€™ïƒ  S.

Sïƒ  A . A
Aïƒ . aA
Aïƒ . b

Aïƒ . aA
Aïƒ . b

Aïƒ  a . A
Aïƒ  b.

Aïƒ . aA
Aïƒ . b

Aïƒ  a . A
Aïƒ  b.

Aïƒ . aA
Aïƒ . b

Aïƒ  a . A
Aïƒ  b.

Sïƒ  AA .

Aïƒ  aA .




3
6
5
3
3
4
4
4










S ïƒ  AA
A ïƒ  aA | b























Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

How to calculate look ahead?
How to calculate look ahead?
Sïƒ CC
Cïƒ  cC | d
Closure(I)
	Sâ€™ïƒ .S,$
	Sïƒ .CC,
	Cïƒ .cC,
	Cïƒ .d,


	Sâ€™	ïƒ 		.	S		,	$
	A	ïƒ 		.	X		,	




$
	S	ïƒ 		.	C	C	,	$
	A	ïƒ 		.	X		,	




c|d
c|d



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: CLR(1)- canonical LR
S ïƒ  AA
A ïƒ  aA | b
Sâ€™ïƒ .S,$
Sïƒ .AA,$

Aïƒ .aA, a|b
Aïƒ .b, a|b

Sâ€™ïƒ  S., $

Sïƒ  A.A,$
Aïƒ .aA, $
Aïƒ . b, $

Aïƒ .aA ,a|b
Aïƒ . b, a|b 

Aïƒ a.A, a|b
Aïƒ  b., a|b

Aïƒ . aA,$
Aïƒ . b, $

Aïƒ  a.A,$
Aïƒ  b. ,$

Aïƒ .aA , a|b
Aïƒ .b , a|b

Aïƒ  a.A , a|b
Aïƒ  b., a|b

Sïƒ  AA. ,$ 

Aïƒ  aA.,a|b




3
8
5
6
3
7
4
4










Augmented grammar
Aïƒ  aA.,$

9
Aïƒ . aA,$
Aïƒ . b, $

Aïƒ  a.A,$
Aïƒ  b. ,S

6
7




LR(1) item set 



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: CLR(1)- canonical LR
S ïƒ  AA
A ïƒ  aA | b
Sâ€™ïƒ .S,$
Sïƒ .AA,$

Aïƒ .aA, a|b
Aïƒ .b, a|b

Sâ€™ïƒ  S., $

Sïƒ  A.A,$
Aïƒ .aA, $
Aïƒ . b, $

Aïƒ .aA ,a|b
Aïƒ . b, a|b 

Aïƒ a.A, a|b
Aïƒ  b., a|b

Aïƒ . aA,$
Aïƒ . b, $

Aïƒ  a.A,$
Aïƒ  b. ,S

Aïƒ .aA , a|b
Aïƒ .b , a|b

Aïƒ  a.A , a|b
Aïƒ  b., a|b

Sïƒ  AA. ,$ 

Aïƒ  aA.,a|b




3
8
5
6
3
7
4
4










Aïƒ  aA.,$

9
	Item set	Action			Go to	
		a	b	$	S	A
	0	S3	S4		1	2
	1			Accept		
	2	S6	S7			5
	3	S3	S4			8
	4	R3	R3			
	5			R1		
	6	S6	S7			9
	7			R3		
	8	R2	R2			
	9			R2		

Aïƒ . aA,$
Aïƒ . b, $

Aïƒ  a.A,$
Aïƒ  b. ,S

6
7



























Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Parsing Methods
Parsing
Top down parsing
Bottom up parsing (Shift reduce)
Back tracking
Parsing without backtracking (predictive Parsing)
LR parsing
Operator precedence
LALR 
CLR 
SLR 
Recursive
 descent 
LL(1) 





Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
 #2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Aïƒ  aA.,a|b
Example: LALR(1)- look ahead LR
S ïƒ  AA
A ïƒ  aA | b
Sâ€™ïƒ .S,$
Sïƒ .AA,$

Aïƒ .aA, a|b
Aïƒ .b, a|b

Sâ€™ïƒ  S., $

Sïƒ  A.A,$
Aïƒ .aA, $
Aïƒ . b, $

Aïƒ .aA ,a|b
Aïƒ . b, a|b 

Aïƒ a.A, a|b
Aïƒ  b., a|b

Aïƒ . aA,$
Aïƒ . b, $

Aïƒ  a.A,$
Aïƒ  b. ,$

Aïƒ .aA , a|b
Aïƒ .b , a|b

Aïƒ  a.A , a|b
Aïƒ  b., a|b

Sïƒ  AA. ,$ 





3
8
5
6
3
7
4
4










Aïƒ  aA.,$

9
Aïƒ . aA,$
Aïƒ . b, $

Aïƒ  a.A,$
Aïƒ  b. ,$

6
7






















CLR

36
Aïƒ .aA , a|b|$
Aïƒ . b, a|b|$ 
Aïƒ a.A, a|b|$
Aïƒ  b., a|b|$

47
Aïƒ  aA.,a|b|$

89



Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Example: LALR(1)- look ahead LR

	Item set	Action			Go to	
		a	b	$	S	A
	0	S3	S4		1	2
	1			Accept		
	2	S6	S7			5
	3	S3	S4			8
	4	R3	R3			
	5			R1		
	6	S6	S7			9
	7			R3		
	8	R2	R2			
	9			R2		


	Item set	Action			Go to	
		a	b	$	S	A
	0	S36	S47		1	2
	1			Accept		
	2	S36	S47			5
	36	S36	S47			89
	47	R3	R3	R3 		
	5			R1		
	89	R2	R2	R2 		
						

CLR Parsing Table
LALR Parsing Table




Prof. Jay R Dhamsaniya
#3130006 (PS)   ï·   Unit 1 â€“ Basic Probability
â€¹#â€º


Prof. Dixita B Kagathara
#2170701 (CD)   ï·   Unit 3 â€“ Parsing Theory (I)
â€¹#â€º

Thank You 





































/docProps/thumbnail.jpeg

