PowerPoint Presentation

Unit – 1
Introduction to
Compiler Design
dixita.kagathara@darshan.ac.in
+91 - 97277 47317 (CE Department)
Computer Engineering Department
Prof. Dixita B. Kagathara
Compiler Design (CD)
GTU # 2170701


Darshan Institute of Engineering & Technology, Rajkot




Looping
Topics to be covered 
Translator
Analysis synthesis model of compilation
Phases of compiler
Grouping of the Phases
Difference between compiler & interpreter
Context of compiler (Cousins of compiler)
Pass structure
Types of compiler











Translator


હેલ્લો







Translator
A translator is a program that takes one form of program as input and converts it into another form. 
Types of translators are:
Compiler
Interpreter
Assembler

Error
Messages 
Translator
Source Program
Target Program
(If any)



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Compiler 
A compiler is a program that reads a program written in source language and translates it into an equivalent program in target language.





Error
Messages 
Source Program
Target Program
Compiler
void main()
{
int a=1,b=2,c;
c=a+b;
printf(“%d”,c);
}
Source Program
0000 1100 0010
0100
0111 1000 0001
1111 0101 1110
1100 0000 1000
1011
Target Program
(If any)



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Interpreter 
Interpreter is also program that reads a program written in source language and translates it into an equivalent program in target language


Interpreter




    




Source Program

Target Program
line by line.

Void main()
 {
     int a=1,b=2,c;
     c=a+b;
     printf(“%d”,c);
 }
0000 1100 0010
0000
1111
1010 1100 0010
0011 1100 0010
1111 1100 0010
Error
Messages 
(If any)



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Assembler 
Assembler is a translator which takes the assembly code as an input and generates the machine code as an output. 




Assembler
MOV id3, R1
MUL #2.0, R1
MOV id2, R2
MUL R2, R1
MOV id1, R2
ADD R2, R1
MOV R1, id1
Assembly Code

0000 1100 0010
0100
0111 1000 0001
1111 0101 1110
1100 0000 1000
1011
1100 0000 1000

Machine Code
Error
Messages 
(If any)



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Analysis Synthesis model of compilation 







Analysis synthesis model of compilation
There are two parts of compilation.

Analysis Phase
Synthesis Phase

Analysis Phase
Synthesis Phase
Intermediate Representation
void main()
{
int a=1,b=2,c;
c=a+b;
printf(“%d”,c);
}
Source Code

0000 1100 
0111 1000 0001
1111 0101 1000
1011
Target Code



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Analysis phase & Synthesis phase
Analysis Phase
Analysis part breaks up the source program into constituent pieces and creates an intermediate representation of the source program.
Analysis phase consists of three sub phases:
 Lexical analysis
 Syntax analysis
 Semantic analysis

Synthesis Phase
The synthesis part constructs the desired target program from the intermediate representation.
Synthesis phase consist of the following sub phases:
 Code optimization
Code generation




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Phases of compiler







Phases of compiler
Compiler
Analysis phase
Synthesis phase
Lexical analysis 
Syntax analysis 
Semantic analysis 


Intermediate code generation
Code optimization 
Code generation 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Lexical analysis
Lexical Analysis is also called linear analysis or scanning.
Lexical Analyzer divides the given source statement into the tokens.
Ex: Position = initial + rate * 60 would be grouped into the following tokens:
	Position (identifier)
	= (Assignment symbol)
	initial (identifier)
	+ (Plus symbol)
	rate (identifier)
	* (Multiplication symbol)
	60 (Number)

Lexical analysis
id1
=
id2
+
id3
*
60







Position = initial + rate*60



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Phases of compiler
Compiler
Analysis phase
Synthesis phase
Lexical analysis 
Syntax analysis 
Semantic analysis 


Intermediate code generation
Code optimization 
Code generation 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Syntax analysis
Syntax Analysis is also called Parsing or Hierarchical Analysis.
The syntax analyzer checks each line of the code and spots every tiny mistake.  
If code is error free then syntax analyzer generates the tree.

Syntax analysis
id1 = id2 + id3 * 60
Lexical analysis
=
id1
+
id2
*
id3
60
Position = initial + rate*60



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Phases of compiler
Compiler
Analysis phase
Synthesis phase
Lexical analysis 
Syntax analysis 
Semantic analysis 


Intermediate code generation
Code optimization 
Code generation 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Semantic analysis
Semantic analyzer determines the meaning of a source string.
It performs following operations: 
matching of parenthesis in the expression. 
Matching of if..else statement.
Performing arithmetic operation that are type compatible. 
Checking the scope of operation.



=
id1
+
id2
*
id3
60
Semantic analysis
=
id1
+
id2
*
id3
inttoreal
60

int to real
*Note: Consider id1, id2 and id3 are real



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Phases of compiler
Compiler
Analysis phase
Synthesis phase
Lexical analysis 
Syntax analysis 
Semantic analysis 


Intermediate code generation
Code optimization 
Code generation 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Intermediate code generator
Two important properties of intermediate code : 
It should be easy to produce.
Easy to translate into target program.
Intermediate form can be represented using “three address code”.
Three address code consist of a sequence of instruction, each of which has at most three operands.


=
id1
+
id2
*
id3
inttoreal
60
Intermediate code 
		t1= int to real(60)
		t2= id3 * t1
		t3= t2 + id2
		id1= t3
t1


t2


t3




Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Phases of compiler
Compiler
Analysis phase
Synthesis phase
Lexical analysis 
Syntax analysis 
Semantic analysis 


Intermediate code generation
Code optimization 
Code generation 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Code optimization
It improves the intermediate code.
This is necessary to have a faster execution of code or less consumption of memory.



Intermediate code 
	           t1= int to real(60)
	t2= id3 * t1
	t3= t2 + id2
		id1= t3
 Code optimization 
		t1= id3 * 60.0
		id1 = id2 + t1





Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Phases of compiler
Compiler
Analysis phase
Synthesis phase
Lexical analysis 
Syntax analysis 
Semantic analysis 


Intermediate code generation
Code optimization 
Code generation 



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Code generation
The intermediate code instructions are translated into sequence of machine instruction.
 Code generation 
		MOV id3, R2
		MUL #60.0, R2
		MOV id2, R1
		ADD R2,R1
		MOV R1, id1


 Code optimization 
		t1= id3 * 60.0
		id1 = id2 + t1
Id3R2
Id2R1



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Phases of compiler
Symbol table
Error detection and recovery
Lexical analysis
Code optimization
Syntax analysis
Semantic analysis
Intermediate code 
Code generation
Target Program
Source program


Analysis Phase
Synthesis Phase

	Variable 
Name	Type	Address
	Position	Float	0001
	Initial 	Float	0005
	Rate	Float	0009




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Exercise
Write output of all the phases of compiler for following statements:
x = b-c*2
I=p*n*r/100 
	





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Grouping of Phases







Front end & back end (Grouping of phases)
Depends primarily on source language and largely independent of the target machine.
It includes following phases: 
Lexical analysis
Syntax analysis 
Semantic analysis
Intermediate code generation 
Creation of symbol table

Front end
Depends on target machine and do not depends on source program.
It includes following phases: 
Code optimization 
Code generation phase 
Error handling and symbol table operation



Back end



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Difference between compiler & interpreter

	Compiler 	Interpreter

	Scans the entire program and translates it as a whole into machine code.	It translates program’s one statement at a time.

	It generates intermediate code.	It does not generate intermediate code.

	Memory requirement is more.	Memory requirement is less.

	An error is displayed after entire program is checked.	An error is displayed for every instruction interpreted if any.

	Example: C compiler 	Example: Basic, Python, Ruby 




Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Context of Compiler
(Cousins of compiler)







Context of compiler (Cousins of compiler)
In addition to compiler, many other system programs are required to generate absolute machine code.
These system programs are:

Preprocessor
Assembler
Linker
Loader 


Skeletal Source Program
Compiler
Assembler
Source Program
Target Assembly 
Program
Relocatable Object Code
Absolute Machine 
Code
Libraries & 
Object Files
Linker / Loader
Preprocessor



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Context of compiler (Cousins of compiler)



Skeletal Source Program
Compiler
Assembler
Source Program
Target Assembly 
Program
Relocatable Object Code
Absolute Machine 
Code
Libraries & 
Object Files
Linker / Loader
Preprocessor
Preprocessor
Some of the task performed by preprocessor:
Macro processing: Allows user to define macros. Ex: #define PI 3.14159265358979323846
File inclusion: A preprocessor may include the header file into the program. Ex: #include<stdio.h>
Rational preprocessor: It provides built in macro for construct like while statement or if statement.
Language extensions: Add capabilities to the language by using built-in macros. 
Ex: the language equal is a database query language embedded in C. Statement beginning with ## are taken by preprocessor to be database access statement unrelated to C and translated into procedure call on routines that perform the database access.





Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Context of compiler (Cousins of compiler)



Skeletal Source Program
Compiler
Assembler
Source Program
Target Assembly 
Program
Relocatable Object Code
Absolute Machine 
Code
Libraries & 
Object Files
Linker / Loader
Preprocessor
Compiler
A compiler is a program that reads a program written in source language and translates it into an equivalent program in target language.







Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Context of compiler (Cousins of compiler)



Skeletal Source Program
Compiler
Assembler
Source Program
Target Assembly 
Program
Relocatable Object Code
Absolute Machine 
Code
Libraries & 
Object Files
Linker / Loader
Preprocessor
Assembler
Assembler is a translator which takes the assembly program (mnemonic) as an input and generates the machine code as an output. 





Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Context of compiler (Cousins of compiler)



Skeletal Source Program
Compiler
Assembler
Source Program
Target Assembly 
Program
Relocatable Object Code
Absolute Machine 
Code
Libraries & 
Object Files
Linker / Loader
Preprocessor
Linker
Linker  makes a single program from a several files of relocatable machine code.
These files may have been the result of several different compilation, and one or more library files.



Loader
The process of loading consists of:
Taking relocatable machine code
Altering the relocatable address 
Placing the altered instructions and data in memory at the proper location.




Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Pass structure







Pass structure
One complete scan of a source program is called pass.
Pass includes reading an input file and writing to the output file.
In a single pass compiler analysis of source statement is immediately followed by synthesis of equivalent target statement.
While in a two pass compiler intermediate code is generated between analysis and synthesis phase.
It is difficult to compile the source program into single pass due to: forward reference 





Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Pass structure
Forward reference: A forward reference of a program entity is a reference to the entity which precedes its definition in the program.
This problem can be solved by postponing the generation of target code until more information concerning the entity becomes available.
It leads to multi pass model of compilation.


Perform analysis of the source program and note relevant information.


In Pass II: Generate target code using information noted in pass I.

Pass I:
Pass II:



Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Effect of reducing the number of passes
It is desirable to have a few passes, because it takes time to read and write intermediate file.
If we group several phases into one pass then memory requirement may be large.




Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1 – Introduction to Compiler Design
‹#›

Types of compiler







Types of compiler
One pass compiler
It is a type of compiler that compiles whole process in one-pass.
Two pass compiler
It is a type of compiler that compiles whole process in two-pass. 
It generates intermediate code.
Incremental compiler
The compiler which compiles only the changed line from the source code and update the object code.
Native code compiler
The compiler used to compile a source code for a same type of platform only.
Cross compiler
The compiler used to compile a source code for a different kinds platform.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
 #2170701 (CD)      Unit 1– Introduction to Compiler Design
‹#›

Thank You 





































/docProps/thumbnail.jpeg