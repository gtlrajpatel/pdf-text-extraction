PowerPoint Presentation

Unit ‚Äì 2
Lexical Analyzer
dixita.kagathara@darshan.ac.in
+91 - 97277 47317 (CE Department)
Computer Engineering Department
Prof. Dixita B. Kagathara
Compiler Design (CD)
GTU # 2170701


Darshan Institute of Engineering & Technology, Rajkot



ÔÅê
Looping
Topics to be covered 
Interaction of scanner & parser
Token, Pattern & Lexemes
Input buffering
Specification of tokens
Regular expression & Regular definition
Transition diagram
Hard coding & automatic generation lexical analyzers
Finite automata
Regular expression to NFA using Thompson's rule
Conversion from NFA to DFA using subset construction method
DFA optimization
Conversion from regular expression to DFA











Interaction with Scanner & Parser







Interaction of scanner & parser
Upon receiving a ‚ÄúGet next token‚Äù command from parser, the lexical analyzer reads the input character until it can identify the next token.
Lexical analyzer also stripping out comments and white space in the form of blanks, tabs, and newline characters from the source program.

Lexical Analyzer
Symbol Table
Parser
Token
Get next token
Source Program



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Why to separate lexical analysis & parsing?
Simplicity in design.
Improves compiler efficiency.
Enhance compiler portability.




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Token, Pattern & Lexemes







Token, Pattern & Lexemes

Sequence of character having a collective meaning is known as token.
Categories of Tokens:
Identifier
Keyword
Operator
Special symbol
Constant


The set of rules called pattern associated with a token. 
Example: ‚Äúnon-empty sequence of digits‚Äù,  ‚Äúletter followed by letters and digits‚Äù 


The sequence of character in a source program matched with a pattern for a token is called lexeme.
Example:  Rate,  DIET, count, Flag

Token
Pattern
Lexemes




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Example: Token, Pattern & Lexemes
Example: total = sum + 45
Tokens:
	total 		
	= 	
	sum 	
	+ 	
	45

Lexemes
	Lexemes of identifier: total, sum
	Lexemes of operator: =, +
	Lexemes of constant: 45

Identifier1
Operator1
Identifier2
Operator2
Constant1

Tokens



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Input buffering







Input buffering
There are mainly two techniques for input buffering:
Buffer pairs
Sentinels


The lexical analysis scans the input string from left to right one character at a time.
Buffer divided into two N-character halves, where N is the number of character on one disk block.

:  :  : E :  : = :  : Mi : * :  :
: C: * : * : 2 :  eof :  :  :
Buffer Pair



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Buffer pairs
Pointer Lexeme Begin, marks the beginning of the current lexeme.
Pointer Forward, scans ahead until a pattern match is found.
Once the next lexeme is determined, forward is set to character at its right end.
Lexeme Begin is set to the character immediately after the lexeme just found.
If forward pointer is at the end of first buffer half then second is filled with N input character.
If forward pointer is at the end of second buffer half then first is filled with N input character.

:  :  : E :  : = :  : Mi : * :  :
: C: * : * : 2 :  eof :  :  :
       forward
      lexeme_beginnig
       forward
: C: * : * : 2 :  eof :  :  :



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Buffer pairs
Code to advance forward pointer
	if forward at end of first half then begin
		reload second half;
		forward := forward + 1;
	end
	else if forward at end of second half then begin
		reload first half;
		move forward to beginning of first half;
	end
	else forward := forward + 1;

:  :  : E :  : = :  : Mi : * :  :
: C: * : * : 2 :  eof :  :  :
       forward
      lexeme_beginnig
       forward
       forward
: C: * : * : 2 :  eof :  :  :



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Sentinels 
In buffer pairs we must check, each time we move the forward pointer that we have not moved off one of the buffers. 
Thus, for each character read, we make two tests.
We can combine the buffer-end test with the test for the current character.
We can reduce the two tests to one if we extend each buffer to hold a sentinel character at the end. 
The sentinel is a special character that cannot be part of the source program, and a natural choice is the character EOF.

:  : E :  : = :  : Mi : * : eof 
: C: * : * : 2 :  eof : : eof
       forward
      lexeme_beginnig



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Sentinels 
forward  := forward + 1;
	if forward  = eof then begin
		if forward at end of first half then begin
			reload second half;
			forward  := forward + 1;
		end	
		else if forward at the second half then begin
			reload first half;
			move forward to beginning of first half;
		end
		else terminate lexical analysis;
	end

:  : E :  : = :  : Mi : * :
: C: * : * : 2 :  eof : : eof
      lexeme_beginnig
       forward
eof
       forward
       forward
: C: * : * : 2 :  eof : : eof



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Specification of tokens







Strings and languages

	Term	Definition

	Prefix of s	A string obtained by removing zero or more trailing symbol of string S.
e.g., ban is prefix of banana.

	Suffix of S	A string obtained by removing zero or more leading symbol of string S.
e.g., nana is suffix of banana.

	Sub string of S	A string obtained by removing prefix and suffix from S.
e.g., nan is substring of banana

	Proper prefix, suffix and substring of S	Any nonempty string x that is respectively proper prefix, suffix or substring of S, such that s‚â†x.

	Subsequence of S	A string obtained by removing zero or more not necessarily contiguous symbol from S.
e.g., baaa is subsequence of banana.




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Exercise
Write prefix, suffix, substring, proper prefix, proper suffix and subsequence of following string:
	String: Compiler




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Operations on languages

	Operation	Definition

	Union of L and M
Written L U M	

	Concatenation of L and M
Written LM	

	Kleene closure of L 
Written L‚àó	

	Positive closure of L 
Written L+	




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular Expression & Regular Definition







Regular expression
A regular expression is a sequence of characters that define a¬†pattern.
Notational shorthand's
One or more instances:  +
Zero or more instances:  *
Zero or one instances:  ?
Alphabets: Œ£




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Rules to define regular expression
is a regular expression that denotes , the set containing empty string.
If   is a symbol in then  is a regular expression, 
Suppose and are regular expression denoting the languages and . Then,
 is a regular expression denoting  
 is a regular expression denoting 
* is a regular expression denoting 
 is a regular expression denoting 

The language denoted by regular expression is said to be a regular set.




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression
L = Zero or More Occurrences of a =



*
a*
a
 aaa
 aa
aaaa
aaaaa‚Ä¶..

Infinite ‚Ä¶..
ùúñ



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression
L = One or More Occurrences of a = 

+
 a+
a
 aaa
 aa
aaaa
aaaaa‚Ä¶..

Infinite ‚Ä¶..



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Precedence and associativity of operators
	Operator	Precedence	Associative
	Kleene *	1	left
	Concatenation	2	left
	Union 	|	3	left




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression examples
0 or 1
	
0 or 11 or 111

String having zero or more a.

String having one or more a.

Regular expression over  that represent all string of length 3.

All binary string
 












+



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression examples
0 or more occurrence of either a or b or both

1 or more occurrence of either a or b or both

Binary no. ends with 0

Binary no. ends with 1

Binary no. starts and ends with 1

String starts and ends with same character
 








+

* 
 







Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression examples
All string of a and b starting with a 

String of 0 and 1 ends with 00 

String ends with abb  

String starts with 1 and ends with 0 

All binary string with at least 3 characters and 3rd character should be zero

Language which consist of exactly two b‚Äôs over the set 


‚Ä¶
*
‚Ä¶

‚Ä¶

‚Ä¶

‚Ä¶

‚Ä¶




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression examples
The language with  such that 3rd character from right end of the string is always a.

Any no. of  followed by any no. of  followed by any no. of 

String should contain at least three 

String should contain exactly two 

Length of string should be at least 1 and at most 3

No. of zero should be multiple of 3


‚Ä¶

‚Ä¶

‚Ä¶.

‚Ä¶.

‚Ä¶.

‚Ä¶.




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression examples
The language with  where  should be multiple of 3

Even no. of 0

String should have odd length

String should have even length

String start with 0 and has odd length

String start with 1 and has even length

All string begins or ends with 00 or 11 



‚Ä¶.

‚Ä¶.

‚Ä¶.

‚Ä¶.

‚Ä¶.






Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression examples
Language of all string containing both 11 and 00 as substring 

String ending with 1 and not contain 00 

Language of C identifier  












Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular definition
A regular definition gives names to certain regular expressions and uses those names in other regular expressions.
Regular definition is a sequence of definitions of the form:


‚Ä¶‚Ä¶

	Where  is a distinct name & is a regular expression.
Example: Regular definition for identifier
	letter ÔÉ† A|B|C|‚Ä¶‚Ä¶‚Ä¶..|Z|a|b|‚Ä¶‚Ä¶‚Ä¶..|z
	digit ÔÉ† 0|1|‚Ä¶‚Ä¶.|9|
	idÔÉ† letter (letter | digit)*




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular definition example
Example: Unsigned Pascal numbers	
	3
	5280
	39.37
6.336E4
1.894E-4
2.56E+7
Regular Definition
	digit ÔÉ† 0|1|‚Ä¶..|9
	digits ÔÉ† digit digit*
	optional_fraction ÔÉ† .digits | ùúñ
	optional_exponent ÔÉ† (E(+|-|ùúñ)digits)|ùúñ
	num ÔÉ† digits optional_fraction optional_exponent






Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Transition Diagram







Transition Diagram
A stylized flowchart is called transition diagram.


is a state

is a transition


is a start state


is a final state



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Transition Diagram : Relational operator

<




2

3

4

5

8

7

=
other
>
=
other
=
>
return (relop,LE)
return (relop,NE)
return (relop,LT)
return (relop,GE)
return (relop,GT)
return (relop,EQ)



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Transition diagram : Unsigned number


8

other
digit





digit
digit
digit
+or -
digit
digit
E
.
start
E
digit
	3
	5280
	39.37
1.894 E - 4
2.56 E + 7
45 E + 6
96 E 2



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Hard coding & automatic generation Lexical analyzers







Hard coding and automatic generation lexical analyzers
Lexical analysis is about identifying the pattern from the input.
To recognize the pattern, transition diagram is constructed.
It is known as hard coding lexical analyzer.
Example: to represent identifier in ‚ÄòC‚Äô, the first character must be letter and other characters are either letter or digits.
To recognize this pattern, hard coding lexical analyzer will work with a transition diagram.
The automatic generation lexical analyzer takes special notation as input.
For example, lex compiler tool will take regular expression as input and finds out the pattern matching to that regular expression.


2
3
Start

Letter or digit
Letter
1



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Finite Automata







Finite Automata
Finite Automata are recognizers.
FA simply say ‚ÄúYes‚Äù or ‚ÄúNo‚Äù about each possible input string.
Finite Automata is a mathematical model consist of:
 Set of states 
 Set of input symbol 
 A transition function move
 Initial state 
 Final states or accepting states 




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Types of finite automata
Types of finite automata are:

Nondeterministic finite¬†automata (NFA): There are no restrictions on the edges leaving a state. There can be several with the same symbol as label and some edges can be labeled with .

1
2
3
4
a
b
b

a
b
1
2
3
4
a
b
b

a
a
a
b
DFA
NFA
b
Deterministic finite automata¬†(DFA): have for each state exactly one edge leaving out for each symbol.

DFA
NFA



Prof. Dixita B Kagathara
 #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression to NFA using Thompson's rule







Regular expression to NFA using Thompson's rule
For  , construct the NFA




For  in , construct the NFA





ùúñ
start



a
start
For regular expression  




Ex: ab





start
N(s)
N(t)
1
2
3
a
b




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression to NFA using Thompson's rule
For regular expression  





Ex: (a|b)






start
N(s)
N(t)




ùúñ
ùúñ
ùúñ
ùúñ
1
2
5
3
4
6
a
b
ùúñ
ùúñ
ùúñ
ùúñ

For regular expression * 





Ex: a*




start
N(s)


ùúñ
ùúñ
ùúñ
ùúñ
1


ùúñ
ùúñ
ùúñ
ùúñ
2
3




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Regular expression to NFA using Thompson's rule
a*b





b*ab


1

ùúñ
ùúñ
ùúñ
2
3




1

ùúñ
ùúñ
ùúñ
ùúñ
2
3


5






Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Exercise
Convert following regular expression to NFA:
abba
bb(a)*
(a|b)*
a* | b*
a(a)*ab 
aa*+ bb*
(a+b)*abb
10(0+1)*1
(a+b)*a(a+b)
(0+1)*010(0+1)*
(010+00)*(10)*
100(1)*00(0+1)*




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA using subset construction method







Subset construction algorithm
Input: An NFA .
Output: A DFA  D accepting the same language.
Method: Algorithm construct a transition table  for D. We use the following operation:

	OPERATION	DESCRIPTION

		Set of NFA states reachable from NFA state  on ‚Äì transition alone.

		Set of NFA states reachable from some NFA state  in  on ‚Äì transition alone.

		Set of NFA states to which there is a transition on input symbol  from some NFA state  in .




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Subset construction algorithm
initially  be the only state in and it is unmarked;
while there is unmarked states T in   do begin
	mark ;
		for each input symbol    do begin
			
			if    is not in  then
				add    as unmarked state to 
			
		end
	end




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA

1
(a|b)
*
abb
2
5
3
4
6
7
8
9
0
10
ùúñ
a
b
ùúñ
a
b
b

ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
9
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
10

 {0, 1, 7, 2, 4}
---- A
ùúñ- Closure(0)=



=  {0,1,2,4,7}



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
9
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
A= {0, 1, 2, 4, 7}
Move(A,a)
= {3,8}
ùúñ- Closure(Move(A,a))
= {3, 6, 7, 1, 2, 4, 8}
---- B



= {1,2,3,4,6,7,8}






10

	States	a	b

	A = {0,1,2,4,7}	B	

	B = {1,2,3,4,6,7,8}		





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA

1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
A= {0, 1, 2, 4, 7} 
Move(A,b) =
 {5}
ùúñ- Closure(Move(A,b)) =
 {5, 6, 7, 1, 2, 4}
---- C



= {1,2,4,5,6,7}





10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}		

	C = {1,2,4,5,6,7}		





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
B = {1, 2, 3, 4, 6, 7, 8}
Move(B,a)
= {3,8}
ùúñ- Closure(Move(B,a))
= {3, 6, 7, 1, 2, 4, 8}
---- B



= {1,2,3,4,6,7,8}





b
10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	

	C = {1,2,4,5,6,7}		





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA

1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
B= {1, 2, 3, 4, 6, 7, 8}
Move(B,b)
= {5,9}
ùúñ- Closure(Move(B,b))
= {5, 6, 7, 1, 2, 4, 9}
---- D



= {1,2,4,5,6,7,9}





b
10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}		

	D = {1,2,4,5,6,7,9}		





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
Move(C,a)
= {3,8}
ùúñ- Closure(Move(C,a))
= {3, 6, 7, 1, 2, 4, 8}
---- B
= {1,2,3,4,6,7,8}





C= {1, 2, 4, 5, 6 ,7}
b
10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}	B	

	D = {1,2,4,5,6,7,9}		





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
Move(C,b) =
 {5}
ùúñ- Closure(Move(C,b))=
 {5, 6, 7, 1, 2, 4}
---- C



= {1,2,4,5,6,7}





C= {1, 2, 4, 5, 6, 7}
10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}	B	C

	D = {1,2,4,5,6,7,9}		





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
Move(D,a)
= {3,8}
ùúñ- Closure(Move(D,a))
= {3, 6, 7, 1, 2, 4, 8}
---- B



= {1,2,3,4,6,7,8}





D= {1, 2, 4, 5, 6, 7, 9}
10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}	B	C

	D = {1,2,4,5,6,7,9}	B	





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
Move(D,b)
= {5,10}
ùúñ- Closure(Move(D,b))
= {5, 6, 7, 1, 2, 4, 10}
---- E



= {1,2,4,5,6,7,10}





D= {1, 2, 4, 5, 6, 7, 9}
10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}	B	C

	D = {1,2,4,5,6,7,9}	B	E

	E = {1,2,4,5,6,7,10}		





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA
1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
Move(E,a)
= {3,8}
ùúñ- Closure(Move(E,a))
= {3, 6, 7, 1, 2, 4, 8}
---- B



= {1,2,3,4,6,7,8}





E= {1, 2, 4, 5, 6, 7, 10}
10

9
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}	B	C

	D = {1,2,4,5,6,7,9}	B	E

	E = {1,2,4,5,6,7,10}	B	





Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA

1
2
5
3
4
6
7
8
0
ùúñ
a
b
ùúñ
a
b
b
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
ùúñ
Move(E,b)=
 {5}
ùúñ- Closure(Move(E,b))=
 {5,6,7,1,2,4}
---- C



= {1,2,4,5,6,7}
	States	a	b

	A = {0,1,2,4,7}	B	C






	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}	B	C


E= {1, 2, 4, 5, 6, 7, 10}
	D = {1,2,4,5,6,7,9}	B	E

	E = {1,2,4,5,6,7,10}	B	C


10

9




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from NFA to DFA



a
b
a
b
a



b
a
b
b
a
Transition Table
DFA
Note: 
Accepting state in NFA is 10
10 is element of E
 So, E is acceptance state in DFA
	States	a	b

	A = {0,1,2,4,7}	B	C

	B = {1,2,3,4,6,7,8}	B	D

	C = {1,2,4,5,6,7}	B	C

	D = {1,2,4,5,6,7,9}	B	E

	E = {1,2,4,5,6,7,10}	B	C




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Exercise
Convert following regular expression to DFA using subset construction method: 
(a+b)*a(a+b)
(a+b)*ab*a




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

DFA optimization







DFA optimization
Construct an initial partition  of the set of states with two groups: the accepting states  and the non-accepting states . 
Apply the repartition procedure to  to construct a new partition . 
If , let and continue with step (4). Otherwise, repeat step (2)    with .
		for each group  of  do begin 
			partition  into subgroups such that two states  and 
				of  are in the same subgroup if and only if for all 
				input symbols , states  and  have transitions on 
				to states in the same group of . 
			replace  in  by the set of all subgroups formed.
end




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

DFA optimization
Choose one state in each group of the partition  as the representative for that group. The representatives will be the states of . Let s be a representative state, and suppose on input a there is a transition of  from  to . Let  be the representative of s group. Then  has a transition from  to  on . Let the start state of  be the representative of the group containing start state  of , and let the accepting states of  be the representatives that are in . 
If  has a dead state , then remove  from . Also remove any state not reachable from the start state.




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

DFA optimization
Now no more splitting is possible.
If we chose A as the representative for group (AC), then we obtain reduced transition table



	A 	B	C

	B	B	D

	C 	B	C

	D 	B	E

	E 	B	C

	States	a	b


Nonaccepting States  
Accepting States  

  

  
	A 	B	A

	B	B	D

	D 	B	E

	E 	B	A

	States	a	b

Optimized Transition Table
  



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA







Rules to compute nullable, firstpos, lastpos
nullable(n)
The subtree at node  generates languages including the empty string.
firstpos(n)
The set of positions that can match the first symbol of a string generated by the subtree at node 
lastpos(n)
The set of positions that can match the last symbol of a string generated be the subtree at node 
followpos(i)
 The set of positions that can follow position  in the tree.




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Rules to compute nullable, firstpos, lastpos
	Node n	nullable(n)	firstpos(n)	lastpos(n)

	A leaf labeled by 	true		

	A leaf with position 	false		

		nullable(c1)
or
nullable(c2)	firstpos(c1) 
ÔÉà 
firstpos(c2)	lastpos(c1) 
ÔÉà 
lastpos(c2)

		nullable(c1) 
and
nullable(c2)	if  (nullable(c1)) 
thenfirstpos(c1) ÔÉà firstpos(c2)
else  firstpos(c1)	if  (nullable(c2)) then  lastpos(c1) ÔÉà lastpos(c2)
else lastpos(c2)

		true	firstpos(c1)	lastpos(c1)


n
c1
c2
n

n

c1
c2
c1



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Rules to compute followpos
If n is concatenation node with left child c1 and right child c2 and i is a position in lastpos(c1), then all position in firstpos(c2) are in followpos(i)

If n is * node and i is position in lastpos(n), then all position in firstpos(n) are in followpos(i)




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA




.



.
.
.



(a|b)
*
abb




#
Step 2: Nullable node

Here, * is only nullable node

Step 1: Construct Syntax Tree



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA




.







.


.


.






Step 3: Calculate firstpos
Firstpos 
A leaf with position 

n
c1
c2
firstpos(c1) ÔÉà firstpos(c2)

n
c1
firstpos(c1) 

n
c1
c2






if  (nullable(c1)) 
thenfirstpos(c1) ÔÉà firstpos(c2)
else  firstpos(c1)



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA




.













.




.




.








Step 3: Calculate lastpos







Lastpos 
A leaf with position 

n
c1
c2
if  (nullable(c2)) then  lastpos(c1) ÔÉà lastpos(c2)
else lastpos(c2)

n
c1
lastpos(c1) 

n
c1
c2
lastpos(c1) ÔÉà lastpos(c2)



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA
	Position 	followpos





.













.




.




.








Step 4: Calculate followpos







	5	6



.







Firstpos
Lastpos 



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA

	Position 	followpos





.













.




.




.








Step 4: Calculate followpos







	5	6



.







	4	5




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA

	Position 	followpos





.













.




.




.








Step 4: Calculate followpos







	5	6



.







	4	5

	3	4

Firstpos
Lastpos 



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA

	Position 	followpos





.













.




.




.








Step 4: Calculate followpos







	5	6



.




	4	5

	3	4

	2	3

	1	3

Firstpos
Lastpos 








Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA

	Position 	followpos





.













.




.




.








Step 4: Calculate followpos







	5	6


	4	5

	3	4

	2	3

	1	3



*
1,2,
1,2,
Firstpos
Lastpos 








Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA
Initial state =  of root = {1,2,3} ----- A
State A
Œ¥( (1,2,3),a) = followpos(1) U followpos(3)
		=(1,2,3) U (4) = {1,2,3,4} ----- B

Œ¥( (1,2,3),b) = followpos(2) 
		=(1,2,3) ----- A

	Position 	followpos

	5	6

	4	5

	3	4

	2	1,2,3

	1	1,2,3

	States	a	b

	A={1,2,3}	B	A

	B={1,2,3,4}		






Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA
State B
Œ¥( (1,2,3,4),a) = followpos(1) U followpos(3)
		=(1,2,3) U (4) = {1,2,3,4} ----- B

Œ¥( (1,2,3,4),b) = followpos(2) U followpos(4)
 		=(1,2,3) U (5) = {1,2,3,5} ----- C
State C
Œ¥( (1,2,3,5),a) = followpos(1) U followpos(3)
		=(1,2,3) U (4) = {1,2,3,4} ----- B

Œ¥( (1,2,3,5),b) = followpos(2) U followpos(5)
 		=(1,2,3) U (6) = {1,2,3,6} ----- D

	Position 	followpos

	5	6

	4	5

	3	4

	2	1,2,3

	1	1,2,3

	States	a	b

	A={1,2,3}	B	A

	B={1,2,3,4}	B	C

	C={1,2,3,5}	B	D





	D={1,2,3,6}		




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA
State D
Œ¥( (1,2,3,6),a) = followpos(1) U followpos(3)
		=(1,2,3) U (4) = {1,2,3,4} ----- B

Œ¥( (1,2,3,6),b) = followpos(2) 
 		=(1,2,3)  ----- A

	Position 	followpos

	5	6

	4	5

	3	4

	2	1,2,3

	1	1,2,3

	States	a	b

	A={1,2,3}	B	A

	B={1,2,3,4}	B	C

	C={1,2,3,5}	B	D

	D={1,2,3,6}	B	A



A
B
C
D
a
b
b

b
a
a
b
a
DFA



Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Conversion from regular expression to DFA
Construct DFA for following regular expression:
(c | d)*c#




Prof. Dixita B Kagathara
  #2170701 (CD)   ÔÅ∑   Unit 2 ‚Äì Lexical Analyzer
‚Äπ#‚Ä∫

Thank You





































/docProps/thumbnail.jpeg