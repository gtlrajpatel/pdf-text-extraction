PowerPoint Presentation

Unit – 3
Parsing Theory (II)
dixita.kagathara@darshan.ac.in
+91 - 97277 47317 (CE Department)
Computer Engineering Department
Prof. Dixita B. Kagathara
Compiler Design (CD)
GTU # 2170701


Darshan Institute of Engineering & Technology, Rajkot




Looping
Topics to be covered 
Syntax directed definitions
Synthesized attributes
Inherited attribute
Dependency graph
Evaluation order
Construction of syntax tree 
Bottom up evaluation of S-attributed definitions
L-Attributed definitions
Translation scheme













Syntax directed definitions







Syntax directed definitions
Syntax directed definition is a generalization of context free grammar in which each grammar symbol has an associated set of attributes.
The attributes can be a number, type, memory location, return type etc….
Types of attributes are:
 Synthesized attribute
 Inherited attribute

E.
Value
Type
Memory location
Return Type



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Synthesized attributes 
Value of synthesized attribute at a node can be computed from the value of attributes at the children of that node in the parse tree.
A syntax directed definition that uses synthesized attribute exclusively is said to be S-attribute definition.
Example: Syntax directed definition of simple desk calculator


	Production 	Semantic rules
	L  En	Print (E.val)
	E  E1+T	E.val = E1.val + T.val
	E  T	E.val = T.val
	T  T1*F	T.val = T1.val * F.val
	T  F	T.val = F.val
	F  (E)	F.val = E.val
	F  digit	F.val = digit.lexval











Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Example: Synthesized attributes 
L
E.val=19

n
+
T.val=15

E.val=15

*
F.val=3
T.val=3
digit.lexval=3
F.val=4
T.val=4
digit.lexval=4
F.val=5

digit.lexval=5

	Production 	Semantic rules 
	L  En	Print (E.val)
	E  E1+T	E.Val = E1.val + T.val
	E  T	E.Val = T.val
	T  T1*F	T.Val = T1.val * F.val
	T  F	T.Val = F.val
	F  (E)	F.Val = E.val
	F  digit	F.Val = digit . lexval

Annotated parse tree for 3*5+4n
parse tree showing the value of the attributes at each node is called Annotated parse tree

The process of computing the attribute values at the node is called annotating or decorating the parse tree
String: 3*5+4n;



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Exercise
Draw Annotated Parse tree for following:
7+3*2n
(3+4)*(5+6)n




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Syntax directed definition to translates arithmetic expressions from infix to prefix notation

	Production 	Semantic rules
	LE	Print(E.val)
	EE+T	E.val=’+’ E.val T.val
	EE-T	E.val=’-‘ E.val T.val
	ET	E.val= T.val
	TT*F	T.val=’*’ T.val F.val
	TT/F	T.val=’/’ T.val F.val
	TF	T.val= F.val
	FF^P	F.val=’^’ F.val P.val
	FP	F.val= P.val
	P(E)	P.val= E.val
	Pdigit	P.val=digit.lexval















Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Inherited attribute
An inherited value at a node in a parse tree is computed from the value of attributes at the parent and/or siblings of the node.








Symbol T is associated with a synthesized attribute type.
Symbol L is associated with an inherited attribute in.



	Production	Semantic rules
	D → T L	L.in = T.type
	T → int		T.type = integer
	T → real		T.type = real
	L → L1 , id	L1.in = L.in,   addtype(id.entry,L.in)
	L → id	addtype(id.entry,L.in)






Syntax directed definition with inherited attribute L.in



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Example: Inherited attribute
Example: Pass data types to all identifier real id1,id2,id3

	Production	Semantic rules
	D → T L	L.in = T.type
	T → int		T.type = integer
	T → real		T.type = real
	L → L1 , id	L1.in = L.in,   addtype(id.entry,L.in)
	L → id	addtype(id.entry,L.in)

D

T.type=real

L
real

T

L.in=real
,

L1
L.in=real
id
,

L1
L.in=real
id
id

id3
id2
id1
DTL
L → L1 , id
L →  id



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Dependency graph







Dependency graph
The directed graph that represents the interdependencies between synthesized and inherited attribute at nodes in the parse tree is called dependency graph.
For the rule XYZ the semantic action is given by X.x=f(Y.y, Z.z) then synthesized attribute X.x depends on attributes Y.y and Z.z.
The basic idea behind dependency graphs is for a compiler to look for various kinds of dependency among statements to prevent their execution in wrong order.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Algorithm : Dependency graph
for each node n in the parse tree do
	for each attribute a of the grammar symbol at n do
		Construct a node in the dependency graph for a;
for each node n in the parse tree do
	for each semantic rule b=f(c1,c2,…..,ck)
		associated with the production used at n do
	for i=1 to k do
		construct an edge from the node for Ci to the node for b;





Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Example: Dependency graph
Example:
EE1+E2

	Production 	Semantic rules 
	EE1+E2	E.val = E1.val+E2.val
		




val
val
val
E
E1
E2
+
 is synthesized from  and 
Parse tree
Dependency graph
The edges to E.val from E1.val and E2.val shows that E.val is depends on E1.val and E2.val



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Evaluation order
A topological sort of a directed acyclic graph is any ordering of the nodes of the graph such that edges go from nodes earlier in the ordering to later nodes.
If is an edge from  to  then   appears before  in the ordering.
D

T.type=real

real

L.in=real
,

L.in=real
L.in=real
id3
id2
id1
,

1
2
3
4
5
6
7



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Construction of syntax tree







Construction of syntax tree
Following functions are used to create the nodes of the syntax tree.
Mknode (op,left,right): creates an operator node with label op and two fields containing pointers to left and right.
Mkleaf (id, entry): creates an identifier node with label id and a field containing entry, a pointer to the symbol table entry for the identifier.
Mkleaf (num, val): creates a number node with label num and a field containing val, the value of the number.




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Construction of syntax tree for expressions
Example: construct syntax tree for a-4+c
P1: mkleaf(id, entry for a);
P2: mkleaf(num, 4);
P3: mknode(‘-‘,p1,p2);
P4: mkleaf(id, entry for c);
P5: mknode(‘+’,p3,p4);

	id	

	Num 	4

	id	

	-		

P1
P2
P3
P4
P5
	+		

Entry for a
Entry for c



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Bottom up evaluation of 
S-attributed definitions







Bottom up evaluation of S-attributed definitions
S-attributed definition is one such class of syntax directed definition with synthesized attributes only.
Synthesized attributes can be evaluated using bottom up parser only.
Synthesized attributes on the parser stack
Consider the production AXYZ and associated semantic action is A.a=f(X.x, Y.y, Z.z)

	State 	Value 
		
		
		

top
Before reduction
	State 	Value 
		
		
		

top
After reduction
top-1
top-2 




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Bottom up evaluation of S-attributed definitions

	Production 	Semantic rules
	L  En	Print (val[top])
	E  E1+T	val[top]=val[top-2] + val[top]
	E  T	
	T  T1*F	val[top]=val[top-2] * val[top]
	T  F	
	F  (E)	val[top]=val[top-2] - val[top]
	F  digit	

	Input	State	Val	Production Used

	3*5n	-	-	

	*5n	3	3	

	*5n	F	3	Fdigit

	*5n	T	3	TF

	5n	T*	3	

	n	T*5	3,5	

	n	T*F	3,5	Fdigit

	n	T	15	TT1*F

	n	E	15	ET

		En	15	

		L	15	L  En



































Implementation of a desk calculator with bottom  up parser 
Move made by translator



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

L-Attributed definitions







L-Attributed definitions
A syntax directed definition is L-attributed if each inherited attribute of , , on the right side of depends only on:
The attributes of the symbols j-1to the left of  in the production and
The inherited attribute of A.
Example:






Above syntax directed definition is not L-attributed because the inherited attribute Q.i of the grammar symbol Q depends on the attribute R.s of the grammar symbol to its right.

	Production	Semantic Rules
	A LM	L.i:=l(A.i)
M.i=m(L.s)
A.s=f(M.s)
	A QR
 	R.i=r(A.i)
Q.i=q(R.s)  A.s=f(Q.s)

L- Attributed 
Not L- Attributed 
AXYZ




Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Translation scheme







Bottom up evaluation of S-attributed definitions
Translation scheme is a context free grammar in which attributes are associated with the grammar symbols and semantic actions enclosed between braces { } are inserted within the right sides of productions.
Attributes are used to evaluate the expression along the process of parsing.
During the process of parsing the evaluation of attribute takes place by consulting the semantic action enclosed in { }.
A translation scheme generates the output by executing the semantic actions in an ordered manner.
This process uses the depth first traversal.



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Example: Translation scheme (Infix to postfix notation)
ETR
R addop R1 | 𝜖
T num 


String: 9-5+2
E 

T

R
-

R
𝜖
9

{Print(9)}

T

{Print(-)}

5

{Print(5)}

+

R
T

{Print(+)}

2

{Print(2)}

Postfix=95-2+
Now, Perform Depth first traversal



Prof. Jay R Dhamsaniya
#3130006 (PS)      Unit 1 – Basic Probability
‹#›


Prof. Dixita B Kagathara
#2170701 (CD)      Unit 3 – Parsing Theory (II)
‹#›

Thank You 





































/docProps/thumbnail.jpeg